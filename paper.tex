\documentclass[a4paper, twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{blindtext}
\usepackage{cite}
\usepackage{comment}
\usepackage[a4paper,left=3cm,right=3cm,top=4cm,bottom=4cm]{geometry}

\title{\Large{Research Seminar Software Science} \\
\huge{Simulation of monadic effects in Haskell}}
\author{Brigel Pineti}
\date{April 2018}

\begin{document}

\maketitle

\section*{Abstract}

\section{Introduction}

Pure function languages like Haskell rule out side effects. Why? Firstly, to allow unrestricted application of program transformation and equation logic. Secondly, being a non-strict language, Haskell's order of side effects is undefined. The aim of this paper is to show how monads can be used to exploit impure effects into a pure language. The code snippets attached to this paper are implemented in Haskell. Section 2 will provide an overview on the characteristics of the language being used. Section 3 is using the Maybe Monad as an illustrative example to get the reader's feet wet with the complex concept of a Monadic value. The application of monads is demonstrated with three case studies.

\section{Haskell}

In this section are reflected two main features concerning the above mentioned functional language. Taking into consideration that not every reader might be familiar with the properties of the language, I found it necessary to briefly illustrate the laziness and purity of Haskell.  

\subsection{Lazy Evaluation}

Haskell is a functional language with non-strict semantics. What does this mean? An expression is evaluated from the outside in. For instance, the evaluation of \textit{$(a + (b * c))$} will firstly reduce the \textit{$+$} operator and then the inner bracket \textit{$(a * b)$}. \\
Lazy evaluation is just an implementation approach for a non-strict language. An appropriate definition for laziness can be represented by the term \textit{call-by-need}. Consequently, the evaluation of an expression is delayed until its result is actually needed from another computation. Therefore, the parameters of a function are evaluated only when they are needed and not a moment before. An advantage of laziness 

\subsection{Absence of Side Effects}

A straightforward consequence of laziness is the evaluation order of a Haskell program. Being demand-driven, it becomes impossible for a function call to produce any side effects. Therefore, Haskell is considered to be a \textit{pure language}. For example, a function of type $Char \rightarrow Char$ will neither write nor read any mutable variables. Nevertheless, side effects are without any doubt very convenient. Haskell's restricted side effects resulted in a sluggish input/output. For this reason, monadic I/O was created; thus by leading to a functional language with side effects. 
\section{Monads}

There exists a certain complexity when it comes to grasping to concept of a monad. From history, monads were initially adopted in Haskell to produce input and output operations. However, the capabilities of monads were not bound to just I/O. Additionally, monads can support multiple operations such as state, non-determinism, continuations, exceptions etc. \\ \\ 
The default monad is composed by three esential components: 
\begin{itemize}
    \item a type constructor
    \item a function return
    \item a bind operator ($\gg$=)
\end{itemize}
The \textit{return} function and the bind operator ($\gg$=) have the following types: 

\begin{center}
   return   :: a $\rightarrow$ m a \\
   ($\gg$=) :: m a $\rightarrow$ (a $\rightarrow$ m b) $\rightarrow$ m b 
   \end{center}
In order for the above function definitions to hold, the three monadic laws need to be satisfied.

The Maybe monad has been selected to provide a concrete insight on how a monad functions.   


\end{document}
