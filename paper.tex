\documentclass[a4paper, onecolumn]{article}
    \usepackage[utf8]{inputenc}
    \usepackage{blindtext}
    \usepackage{cite}
    \usepackage{comment}
    \usepackage{color}
    \usepackage{listings}
    \usepackage{tcolorbox}
    \usepackage[a4paper,left=2.9cm,right=2.9cm,top=4cm,bottom=4cm]{geometry}
    
    \title{\Large{Research Seminar Software Science} \\
    \huge{Simulation of monadic effects in Haskell}}
    \author{Brigel Pineti}
    \date{April 2018}
    
    \begin{document}
    
    \maketitle
    
    \section*{Abstract}
    
    TODO: Write once the paper is coming to an end!
    
    \section{Introduction}
    
    Pure function languages like Haskell rule out side effects. Why? Firstly, to allow unrestricted application of program transformation and equation logic. Secondly, being a non-strict language, Haskell's order of side effects is undefined. The aim of this paper is to show how monads can be used to capture impure effects into a pure language. The code snippets attached to this paper are implemented in Haskell. Section 2 will provide an overview on the characteristics of the language being used. Section 3 describes the construction of a monad, the various monadic flavors and the Maybe Monad as an illustrative example to get the reader's feet wet with the complex concept of a Monadic value. The application of monads is demonstrated with one case study to construct recursive decent parsers. \textit{(more cases studies to be added on next intermediate presentation)} 
    
    \section{Haskell}
    
    In this section are reflected two main features concerning the above mentioned functional language. Taking into consideration that not every reader might be familiar with the properties of the language, I found it necessary to briefly illustrate the laziness and purity of Haskell.  
    
    \subsection{Lazy Evaluation}
    
    Haskell is a functional language with non-strict semantics. What does this mean? An expression is evaluated from the outside in. For instance, the evaluation of \textit{$(a + (b * c))$} will firstly reduce the \textit{$+$} operator and then the inner bracket \textit{$(a * b)$}. \\
    Lazy evaluation is just an implementation approach for a non-strict language. An appropriate definition for laziness can be represented by the term \textit{call-by-need}. Consequently, the evaluation of an expression is delayed until its result is actually needed from another computation. Therefore, the parameters of a function are evaluated only when they are needed and not a moment before.
    
    \subsection{Absence of Side Effects}
    
    A straightforward consequence of laziness is the evaluation order of a Haskell program. Being demand-driven, it becomes impossible for a function call to produce any side effects. Therefore, Haskell is considered to be a \textit{pure language}. For example, a function of type $Char \rightarrow Char$ will neither write nor read any mutable variables. Nevertheless, side effects are without any doubt very convenient. Haskell's restricted side effects resulted in a sluggish input/output. For this reason, monadic I/O was created; thus by leading to a functional language with side effects. 
    \section{Monads}
    Monads originate from a section of mathematics called category theory \cite{categorytheory}. Luckily for the inexperienced readers, it is not required to have prior knowledge in category theory in order to comprehend the application of monads in Haskell. 
    Nevertheless, there exists a certain complexity when it comes to grasping to concept of a monad. From history, monads were initially adopted in Haskell to produce input and output operations. However, the capabilities of monads were not bound to just I/O. Additionally, monads can support multiple operations such as state, non-determinism, continuations, exceptions etc.
    \subsection{Construction}
    For now think of a monad as a way of chaining operations together. 
    In order to have a monad, three components are essential to its construction: 
    \begin{itemize}
        \item a type constructor
        \item a function return
        \item a bind operator ($\gg$=)
    \end{itemize}
    The \textit{return} function and the bind operator ($\gg$=) have the following types: 
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
       return :: a -> M a 
       (>>=)  :: M a -> (a -> M b) -> M b 
      \end{lstlisting}
    \end{tcolorbox}
    In order for the above function definitions to hold, the monad laws need to be satisfied. There exist three monadic laws as presented below: 
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
    right unit             m >>= return  =  m 
    left  unit      return x >>= f       =  f x   
    associative    (m >>= f) >>= g       =  m >>= (\x -> f x >>= g) 
      \end{lstlisting}
    \end{tcolorbox}
    
    According to the laws of right and left unit, the return serves as a collector of a value where no computation occurs. As the type of \textit{return} suggests, it takes a value of type \textit{a}, puts it in a special context \textit{m} and returns as a result \textit{m a}. Furthermore, the associative law guarantees that the bind operator ($\gg$=) is concerned only with the order of computation and not on the manner the operators are nested together. The bind operation can be compared to a semicolon(;) by taking the output from the former step and feeding it to the next step.
    \subsection{Flavors}
    
    It is crucial to understand that there exist more than one kind of monad. As a result, the implementation of the bind function ($\gg$=) mentioned on the previous section differs on various monads. 
    
    \begin{itemize}
        \item \textbf{Fail Monad} - Consider the case that each step will \textit{return} either a success or a fail. The bind operator can be constructed in such a way that the next step will be executed only if the former step succeeds. Hence, there is no need to check if the previous step failed since the \textit{fail monad} will take care of this by automatically aborting in case of a former failing step.
        \begin{center}
            \textbf{data} Failure \textit{a} = Fail $\vert$ Success \textit{a} 
        \end{center}
        \item \textbf{Exception Monad} - Either returns a values or raises an exception. Since it is up to the developer to implement such a monad, he/she may decide to ignore the first exception and throw an exception only if a second one is found. 
        \begin{center}
            \textbf{data} Exc \textit{e a} = Exception \textit{e} $\vert$ OK \textit{a}
        \end{center}
        \item \textbf{List Monad} - Models non-deterministic computation and return a sequence of values. There exists the opportunity to program each step to return multiple values. The bind operator ($\gg$=) may be used to iterate over these values and pass each value to the upcoming step. Otherwise various loops would be needed to deal with all these results. As it can be seen, the bind operator of the list monad would be very beneficial by removing the complexity of adding loops to retrieve information. 
        \begin{center}
            \textbf{type} List \textit{a} = [\textit{a}]
        \end{center}
        \item \textbf{State Reader Monad} - Accepts a state as an input and reads a value of type \textit{a} without performing any computation on the state itself. The bind operator can be used to pass additional data with the sole purpose to access it from anywhere without the necessity to manually pass data to every step in order to read it. 
        \begin{center}
            \textbf{type} SR \textit{s a} = \textit{s} $\rightarrow$ \textit{a}
        \end{center}
        \item \textbf{State Transformer Monad} - Mainly used to thread the state during program execution. The transformer takes the old state as an input and returns a tuple of the value of type \textit{a} and the new state. Additionally, the state transformer is perfect for simulating update operations.
        \begin{center}
            \textbf{type} ST \textit{s a} = \textit{s} $\rightarrow$ (\textit{a}, \textit{s})
        \end{center}
        \item \textbf{Parser Monad} - Extremely helpful in modeling parsers. The input is a String to be parsed and the output is a list containing the parsed value of type \textit{a} and the remaining unparsed String. The list represents all the possible parses of the input String; being empty if nothing is parsed, having only one parse if there is one parse and so on. The parser monad is equivalent to the combination between the list monad and the state transformer monad.  
        \begin{center}
            \textbf{type} Parser \textit{a} = String $\rightarrow$ [(\textit{a}, String)] 
        \end{center}
    \end{itemize}
    It is thought-provoking how any type can act as a \textit{Monad} just by defining some functions that comply with the three monadic laws in order to guarantee that the composition of functions with side effects is \textit{associative} and has an \textit{identity} \cite{essenceFP}.
    
    \subsection{Maybe}
    The Maybe monad has been selected to provide a concrete insight on how a monad works in practice. The nature of Maybe provides a smooth solution to situations where some function may or may not return a value. The type constructor is presented below:
    
    \begin{center}
        \textbf{data} Maybe \textit{a} = Just \textit{a} $\vert$ Nothing 
    \end{center}
    The Maybe type constructor suggests that for any value of type \textit{a}, it returns either \textit{Just} that value or \textit{Nothing}. The \textit{return} and ($\gg$=) are defined like this:
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
        return :: a -> Maybe a
        return x     = Just x 
    \end{lstlisting}
    \end{tcolorbox}
    The \textbf{return} will take as an input a normal value and place it inside the context of a Maybe value. In this case, it is placed inside the \textbf{Just} value constructor. For example: 
    
    \begin{center}
        ghci$>$ \textbf{return} \textit{``hello"}
    \end{center}
    The resulting value of the above operation will be \textbf{Just} \textit{``hello"}.
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
        (>>=) :: Maybe a -> (\a -> Maybe b) -> Maybe b
        Nothing >>= f = Nothing
        Just x  >>= f = f x
    \end{lstlisting}
    \end{tcolorbox}
    The binding operator ($\gg$=) takes \textbf{Maybe a} and a function of type \textbf{a $\rightarrow$ Maybe b} and somehow applies the function to \textbf{Maybe a} in order to return \textbf{Maybe b}. An example might be useful to illustrate this: 
    \begin{center}
    ghci$>$ \textbf{Just} \textit{``smile"} $\gg=$ \textbackslash x $\rightarrow$ \textbf{Just} (\textit{x} ++ \textit{`` :)"})
    \end{center}
    When the function is applied to \textbf{Just ``smile"}, it removes \textbf{``smile"} from its special context and passes it as an input to the function \textbf{\textbackslash x $\rightarrow$ Just (x ++ `` :)")}.  The function will return \textbf{Just ``smile :)"}. This is what I call magic! On the other hand, replacing \textbf{Just ``smile"} with the value constructor \textbf{Nothing} will always result in \textbf{Nothing} being independent from the function \textbf{f}.
    
    
    \subsection{Conclusions}
    A monad is helpful in chaining various computations together and managing how that chain of action functions as a unit. In addition, the monadic laws will be in charge of supervising two imperative cases:
    
    \begin{itemize}
        \item state between actions by guaranteeing that they are executed in the appropriate order 
        \item failing situations by ensuring that upcoming actions are aborted and the whole expression is evaluated to a failure
    \end{itemize}
    Therefore, it is essential to understand how the Maybe types work as a Monad in order to then comprehend more complicated Monads like \textit{State} and \textit{IO}.
    
    \section{Lists}
    This section shows how the monadic behaviour of lists can be used in our advantage to explicitly demonstrate non-determinism. \\ \\
    In general, lists can be both \textit{deterministic} and \textit{non-deterministic}. For instance, take into consideration a list containing just one element \textbf{[27]}. Clearly, the former list is deterministic since it accommodates a single value and it is apparent that the value equals to 27. On the other hand, a list enclosing more than one element \textbf{[27, 6, 21]} introduces non-deterministic behaviour since it can have many outcomes at the same time. \\ \\
    The notion of \textit{non-determinism} can be decoded smoothly in monadic terms. Below is illustrate how the Monad instance is defined for a list: \\
    \begin{lstlisting}[language=Haskell]
        instance Monad [] where
            return x = [x]
            xs >>= f = concat (map f xs)
    \end{lstlisting} 
    The \textbf{return} wraps a values of type \textit{x} and places it into the special context of a list. In other words, it creates a list that contains only that single value. Afterwards, this not so simple value anymore can interact with other values to produce a non-deterministic nature.   \\ \\
    The bind operator \textbf{($>>$=)} is taking a monadic list, removing its elements from the monadic context and feeding them into a function that takes normal values and returns again monadic list.  In order to remove the confusion, the example below can be used to clarify the complexity of the bind operator: \\
    \begin{lstlisting}[language=Haskell]
       ghci> [3, 6, 10] >>= \x -> [x, 2*x]
       [3, 6, 6, 12, 10, 20]
    \end{lstlisting} \\
    Therefore, the purpose of the bind operator is to facilitate the non-deterministic attitude of lists. \textbf{[3, 6, 10]} is a non-deterministic list that is being feed into a function that itself returns a non-deterministic list. Hence, the final result will be a non-deterministic list containing all the possible combinations between the elements of the list \textbf{[3, 6, 10]} and the passing of these values to the function \textbf{\textbackslash x $\rightarrow$ [x, 2*x]}. The job of the function is straightforward. The function generates two outcomes for each element of the input list, the original value and the value multiplied by 2. 
    
    
    
    \section{Parsers}
    Monads are valuable in modeling sequencing and alternation in recursive decent parsers. The methods described in this section are extensible since parsers are treated as first-class values and combinators are defined in Haskell. Additionally, it portrays the purity of functional programming.
    
    \subsection{State Transformers}
    
    Parsers in functional programming are pictured as state transformers \cite{original}. Recall state transformers monads from section 3.2.  
    
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
      type Parse p = State -> [(p, State)]
      type State    = String  
      
      \end{lstlisting}
    \end{tcolorbox}
    
    The parser of type \textit{p} takes a state represented as a string ready to be parsed and returns a list containing the value of type \textit{p} parsed from the string and a state represented again as a string that is yet to be parsed. Since a parser may not consume all of its input string, the unconsumed suffix of the input must be returned along with the prefix of the input. As a result, the outcome of a parser must be a list enclosing consumed and unconsumed part of the input string. Additionally, the case when an empty list is returned is treated as a failure \cite{pearls}. On the other hand, an non-empty list is marked as a success. Lets take into consideration a straightforward parser for multiplication operations.
    
    \begin{center}
        \textbf{data} Expr = Const \textit{Int} $\vert$ Multi \textit{Expr} \textit{Expr} 
    \end{center}
    
    Next, lets create a parser of type Expr. 
    
    \begin{center}
        parseExpr :: \textbf{Parse} \textit{Expr} 
    \end{center}
    
    The following examples take as input the state defined as a string. 
    
    \begin{lstlisting}[language=Haskell]
        parseExpr "27 or twentyseven" = [(Const 27, " or twentyseven")] 
        parseExpr "twentyseven"       = []
    \end{lstlisting}
    
    For simplicity, the focus will remain on parsers that either fail and return an empty list of results, or succeed and return a singleton list.
    
    \subsection{Primitive Parsers}
    
    This subsection will introduce three primitive parsers with the sole purpose to achieve diverse parser combinators. \\ \\
    Firstly, the parser oneItem will fail if the input provided is an empty list. Otherwise, it will eat only the first character of the input string and leave the other part of the input unconsumed. This parser is defined by applying pattern matching on the list. 
     
    
    \begin{lstlisting}[language=Haskell]
      oneItem         :: Parse Char
      oneItem []       = []
      oneItem (l : ls) = [(l, ls)]
    \end{lstlisting}
    
    To better illustrate follow the examples below that treat both cases.
    
    \begin{lstlisting}[language=Haskell]
      oneItem ""       = []
      oneItem "parser" = [('p', "arser")]
    \end{lstlisting}
    Secondly, the parser \textbf{zero} will always fail, regardless of the input string provided. 
    
    \begin{lstlisting}[language=Haskell]
      zero :: Parse p
      zero = \input -> [] 
    \end{lstlisting}
    
    In other words, the outcome of the \textbf{zero} parser will always be an empty list. \\ \\
    Finally, the \textbf{result v} parser will always succeed by returning the value \textit{v} without consuming any input.
    
    \begin{lstlisting}[language=Haskell]
      result :: p -> Parse p
      result v input = [(v, input)]
    \end{lstlisting}
    
    \subsection{Parser Combinators}
    
    The three primitive parsers that were defined in the previous subsection aren't very helpful when used separately. Hence, these parsers have to be combined together through some operators in order to actually produce something useful. In this subsection, two operators are introduced: \textit{sequence} and \textit{alternation}. 
    
    \subsubsection{Sequencing}
    
    Sequencing of parsers is usually captured by a combinator called \textit{seq} where two parsers are applied one after another with the result from the two parsers being combined together as a tuple. The example below will illustrate the definition of the \textit{seq} operator:
    
    \begin{tcolorbox}
    
    \begin{lstlisting}[language=Haskell]
      seq :: Parse a -> Parse b -> Parser (a, b)
      p `seq` q = \input -> [((v, u), input'') | (v, input') <- p input,
                                                (u, input'') <- q input']
    \end{lstlisting}
    \end{tcolorbox}
    
    In order to define the \textit{seq} operator, list comprehensions come in handy. Initially, the right side of the vertical bar is executed. In case, the parser \textbf{p} takes a non-empty \textbf{input} string, then a list of pairs will be returned accommodating the consumed prefix of the \textbf{input} and the unconsumed suffix of the \textbf{input}. The resulting list of pairs for the parser \textbf{p input} is \textbf{(v, input')}. \\ \\ Immediately after the parser \textbf{p} has accomplished it's goal, the parser \textbf{q} will take as an input string the un-parsed string from the former parser. In other words, the parser \textbf{q} takes as an input string the string \textbf{input'}. The outcome of the parser \textbf{q input'} will be the list of pairs \textbf{(w, input'')} where \textbf{u} is the \textit{prefix of the input'} and \textbf{input''} is the \textit{suffix of the input'}. \\ \\
    As a last step (the left side of the vertical bar), the parser combinator \textbf{seq} will sew together the values \textbf{u} and \textbf{v} into a tuple and return a list of pairs like \textbf{[((v, u), input'')]}. \\ \\
    In the above situation, the operator \textbf{seq} will continuously nest tuples together thus be increasing complexity and making it painful to handle. \\ \\
    The headache introduced by the nested tuples can be smoothly averted by adopting monadic sequencing. In order to achieve this type of sequencing the bind operator has been defined. The type of this operator resembles with the type of the bind operator from monad instance \textit{m}. Recalling from the section 3.1 of Monad Construction, the type of ($>>$=) was {\textbf{m a $\rightarrow$ (a $\rightarrow$ m b) $\rightarrow$ m b}}. In the monadic sequencing case, the \textit{m} is being replaced with \textit{Parse}.
    
    \begin{tcolorbox}
    
    \begin{lstlisting}[language=Haskell]
      bind :: Parse a -> (a -> Parse b) -> Parser b
      p `bind` f = \input -> concat [f v input' | (v, input') <- p input]
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{bind} combinator is an infix operator that take a parser from the left side and a function that itself takes a normal value and returns another parser from the right side. The infix \textbf{bind} is defined as a lambda expression taking a string as an input and producing a concatenation of the values parsed by the sequencing of parsers. \\ \\
    At first, the parser \textbf{p} is applied to the input string and results in a list of pairs \textbf{(v, input')} where \textit{v} is the first item exhausted by the parser \textbf{p} and the \textit{input'} is the remaining input string. \\ \\
    Now, the function \textbf{f} applies to the normal value \textbf{v} to form a parser \textbf{f v} which is afterwards applied the string \textbf{input'}. The resulting parser will be a list of concatenated lists. The examples below will help in clarifying any confusion being raised by the \textbf{bind} operator. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseOneItem :: Parse Char
      parseOneItem  = oneItem `bind` \x -> result x 
    \end{lstlisting}
    \end{tcolorbox}
    
    The parser \textbf{parseOneItem} produces that same result as the primitive parser \textbf{oneItem} defined in section 5.2 but their implementation differs. The latter parser is using the former parser in its definition. \\ \\ 
    In practice, the \textbf{oneItem} parser is consuming the first character of an input string and through the \textbf{bind} operator this value is being passed as an input to the lambda function expression \textbf{\textbackslash x $\rightarrow$ result x}. Furthermore, this function is returning the primitive \textbf{result} parser. From section 5.2, the \textbf{result} parser will always succeed by returning the value x that was passed to it without exhausting any input string. In this case, the goal of the \textbf{result} parser is to just display what was parsed and what was not parsed, and doesn't need to worry about parsing since the \textbf{oneItem} parser is taking care of that.  
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseTwoItems :: Parse (Char, Char)
      parseTwoItems  = oneItem `bind` \x -> oneitem 
                               `bind` \y -> result (x, y)
    \end{lstlisting}
    \end{tcolorbox}
    
    The parse \textbf{parseTwoItems} manages to parse the first two characters of the input string and returns the two parsed characters and remaining part of the input string which is not yet parsed. \\ \\
    In practice, the \textbf{parseTwoItems} is using two \textit{bind} infix operators. In the first \textit{bind}, the \textbf{oneItem} parser is eating the first character of the input string and passing the corresponding value to the function \textbf{\textbackslash x $\rightarrow$ oneItem}, which differently from the previous \textbf{parseOneItem} parser is returning another \textbf{oneItem} parser instead of the primitive \textbf{result} parser. In the second \textit{bind}, the  other \textbf{oneItem} parser is devouring the first character of the unparsed input string and passing that value as an input to the function \textbf{\textbackslash y $\rightarrow$ result(x, y)}. Finally, the resulting output will be handled by the \textbf{result} parser which will return the values of \textit{x} and \textit{y} being correspondingly the first and the second character of initial input string, together with the unparsed input string as a tuple. \\ \\ 
    The following example will better illustrate the outcome when parsing a string:
       \begin{center}
            \textbf{ghci$>$} parseTwoItems \textcolor{red}{``rera"} \\
            $\big[$((\textcolor{green}{`r'}, \textcolor{green}{`e'}), \textcolor{red}{``ra"})$\big]$
        \end{center}
        
    From the above example, it can be deduced that the outcome of the first parser can be sequentially consumed by the second parser and so on if other parsers are included. Hence, the \textit{bind} infix operator will dodge the complication introduced by the nested tuples. Consequently, the \textit{seq} can be defined using the \textit{bind} operator: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      p `seq` q = p `bind` \x -> q `bind` \y -> result (x, y)
    \end{lstlisting}
    \end{tcolorbox}
    
    The monadic \textit{bind} operator can be used to define parsers of a different nature. For example, a \textbf{satisfy} combinator may be constructed as a function that takes a predicate as input and returns a parser that consumes the first element of a string if the predicate is true and fails if the predicate is false. In order to fulfill the required parsing behavior, the primitive parsers \textit{oneItem}, \textit{result} and \textit{zero} mentioned in section 5.2 are necessary. Let's observe how the \textbf{satisfy} can be implemented: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      satisfy :: (Char -> Bool) -> Parse Char
      satisfy pred = oneItem `bind` \x -> if pred x 
                                          then result x 
                                          else zero
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{satisfy} combinator will initially parse the first item of the input provided. Afterwards, through the \textit{bind} operator this value is passed as an input to the function taking the first character as an input and returning an if statement as an output. The if statement checks what the predicate returns. If the predicate is true the first value parsed and the unparsed input string are returned through the \textbf{result} parser, otherwise the parser will fail and will return an empty list through the \textbf{zero} parser.  \\ \\
    A benefit of using the monadic approach to define parsers is the support provided by the \textit{monad comprehension syntax} \cite{bringMonadComprehension}. Monad comprehensions will promote readability of parsers. Hence, the satisfy can be transformed into the following structure: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      satisfy pred = [x | x <- oneItem, pred x]
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{satisfy} parser combinator can be easily extended to add precision in parsers. Hence, parsers like \textbf{singleChar}, \textbf{isdigit}. \textbf{islowercase} and \textbf{isuppercase} can be defined:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      singleChar   :: Char -> Parse Char
      singleChar a  = satisfy (\b -> a == b)
      
      isdigit :: Parse Char
      isdigit  = satisfy (\a -> a >= '0' && a <= '9')
      
      islowercase :: Parse Char
      islowercase  = satisfy (\a -> a >= 'a' && a <= 'z')
      
      isuppercase :: Parse Char 
      isuppercase  = satisfy (\a -> a >= 'A' && a <= 'Z')
    \end{lstlisting}
    \end{tcolorbox}
    
    The names for each parser are speaking for themselves. Each of the above parsers will success in parsing the first character if the predicate takes an input for the satisfy combinator is true. On the other hand, the parser will fail and return [ ]. 
    
    In conclusion, it is very important to comprehend that the monadic \textbf{bind} made possible the creation of \textbf{satisfy} and what followed as an extension of \textbf{satisfy}. However, this is not the end of the commodity that the \textbf{bind} operator provides. For instance, a new parser may be created to parse two digits or more if the predicate holds or to fail if it doesn't. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseTwoDigits :: Parse (Char, Char)
      parseTwoDigits  = isdigit `bind` \x -> isdigit 
                                `bind` \y -> result(x,y)
    \end{lstlisting}
    \end{tcolorbox}
    
    Applying this parser to an input string ``12rera" will succeed with the result [((`1', `2'), ``rera")] whereas in case of an input ``1rera" will fail and return [ ] since the second parsed character \textit{`r'} is not a digit. \\ \\
    Nevertheless, it would not be convenient to create new parsers each time more items need to be parsed. For that reason, \textit{recursive parsers} are desired. Additionally, recursive operation must be terminated at some point. In order to achieve or not termination, the \textbf{alternation} combinator has to be used but more on that on the next subsection.
    \subsubsection{Alternation}
    
    In this subsection, the attention will be redirected towards producing alternation in parsers.  The implementation of 2 parsers being alternated together will be represented by the operator (\texttt{+++}) and we will refer to this as the \textbf{plus} parser. Have a look at the following Haskell snippet to understand how alternation is attained:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      (+++) :: Parse a -> Parse a -> Parse a
      p +++ q  = \input -> (p input ++ q input)
    \end{lstlisting}
    \end{tcolorbox}
    \noindent The nature of the plus parser can be illustrated by defining the \textbf{isletter} parser which alternates two of the already defined parsers from the previous subsection: \textbf{islowercase} and \textbf{isuppercase}.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        isletter :: Parse Char
        isletter  = islowercase +++ isuppercase
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textbf{isletter} parser will parse the first character of input string if it is a lowercase or an uppercase letter. How does it accomplish this? Firstly, it will apply parser \textbf{islowercase} to the input string and yield a tuple with resulting parsed character together with remaining not parsed input string. Secondly, it will apply the parser \textbf{isuppercase} to the same input string and return a tuple containing the resulting  parsed character together with the yet to be parsed input string. Finally, it will concatenate the resulting tuples from \textbf{islowercase} and \textbf{isuppercase} parsers into one list. As shown from the example below, the \textbf{isletter} parser is exhibiting the correct behavior by just returning the parsed character is it is a letter.
    
    \begin{center}
            \textbf{ghci$>$} isletter \textcolor{red}{``rera"} \\
            $\big[$(\textcolor{green}{`r'}, \textcolor{red}{``era"})$\big]$
    \end{center}
    
    \noindent Actually, the resulting outcome is the output produced by the \textbf{islowercase} parser while the \textbf{isuppercase} parser returns an empty list. If the \textbf{isuppercase} parser returned a non empty list , the resulting output would be appended to the output of the \textbf{islowercase} parser, thus by producing some ambiguous behavior. In other words, there is an issue with the non-deterministic behavior of the \textbf{plus} parser. \\ \\
    The nature of this complication can be clearly represented by the \textbf{islower\_r} parser which alternates two of the already defined parsers from the previous subsection: \textbf{islowercase} and \textbf{singleChar}. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        islower_r :: Parse Char
        islower_r  = islowercase +++ singleChar `r'
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The role that the \textbf{islower\_r} exhibits is not very useful in parsing terms but in this case it is essential in exposing the hidden inadequate behavior of the \textbf{plus} parser. Now, let's apply the \textbf{islower\_r} parser to an input string that contains `r' as it's first character to observe what happens.
    
    \begin{center}
            \textbf{ghci$>$} islower\_r \textcolor{red}{``rera"} \\
            $\big[$(\textcolor{green}{`r'}, \textcolor{red}{``era"}), (\textcolor{green}{`r'}, \textcolor{red}{``era"})$\big]$
        \end{center}
    
     \noindent The \textbf{islower\_r} parser is producing duplicates inside the list while just one of the duplicates is necessary to be displayed. At the moment, even though the first parser will succeed in parsing the input, the second parser will always be applied to the same input.This is not the desired behaviour from alternation of parsers. The undesired behaviour is intensified by the \textbf{isword} parser which is defined below:
     
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        isword :: Parse String
        isword = word +++ result ""
                   where word = isletter `bind` \x -> isword 
                                         `bind` \xs -> result (x:xs)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent For example let's apply the \textbf{isword} parser to an input string.
    
    \begin{center}
            \textbf{ghci$>$} isword \textcolor{red}{``rera"} \\
               $\big[$(\textcolor{green}{`rera'}, \textcolor{red}{``"}), (\textcolor{green}{`rer'}, \textcolor{red}{``a"})
            (\textcolor{green}{`re'}, \textcolor{red}{``ra"})
            (\textcolor{green}{`r'}, \textcolor{red}{``era"})
            (\textcolor{green}{`'}, \textcolor{red}{``rera"})$\big]$
        \end{center}
        
    \noindent As it can be seen the behavior that the \textbf{isword} parser demonstrates is not as expected. The \textbf{isword} parser is supposed to parse an entire string, thus the only relevant output to be awaited from \textbf{isword ``rera"} is \textbf{[(``rera", ``")]}. \\ \\
      In order to achieve the expected behaviour some changes have to be made to the \textbf{plus} parser. The end goal is to allow the consequent parser to parse the input string only if the initial parser has failed in doing so. Additionally, if the initial parser succeeds in parsing the input, the program is terminated and the parsed result is returned. How can the \textbf{plus} parser be altered so that it can introduce this deterministic behavior? \\ \\ 
      One way to transform the \textbf{plus} parser is by applying the \textit{case of} notation on the output that the first parser \textit{p} produces when applied to the input string. In case, the parser \textit{p} when eating the input string returns a parsed value together with the yet to be parser string then the \textbf{plus} parser terminates and returns the mentioned result. However, if the parser \textit{p} return an empty list after parsing the input string then and only then the second parser \textit{q} will be applied to same input string as parser \textit{p}. The implementation of the transformed \textbf{plus} parser is presented below:
     
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        p +++ q = \input -> case p input of
                              [(val, input')] -> [(val, input')]
                                           [] -> q input
    \end{lstlisting}
    \end{tcolorbox}
     
     \noindent With this modification, some deterministic behaviour has been inserted in the \textbf{plus} parser thus by fixing the sketchy behavior that was being manifested before. \\ \\
     Another way to customize the \textbf{plus} parser is by utilizing the Maybe monad. The following snippet of Haskell code shows how the Just and Nothing constructors can be integrated in the \textbf{plus} parser:
     
     \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        p +++ q = \input -> case p input of
                              Just (val, input') -> Just (val, input')
                                         Nothing -> q input
    \end{lstlisting}
    \end{tcolorbox}
    
    Therefore, both the \textit{List} and the \textit{Maybe} monad in combination with \textit{case of} notation helped in upgrading the behavior of the \textbf{plus} parser. 
    
    
    \subsection{Conclusions}
    
    \section{A Case Study}
    
    In order to properly illustrate the monadic techniques described on section 5, a case study will be conducted on creating a parser in a monadic way for a simple programming language with the following constructs: 
    
    \begin{itemize}
        \item Only \textit{Integer} and \textit{String} variable declarations \\
        \textbf{Integer} a = 42 or \textbf{String} b = `Hello Monads!'
        \item Output functions \\ 
        \textbf{print}(a)
        \item Input functions \\
        \textbf{get}(a)
        \item Variables assignments and operators \\ 
        a \textbf{:=} b where a and b are variables \\ 
        a \textbf{:=} b op c where a, b, and c are variables and op is an \textit{arithmetic operator} (*, /, +, -) or a \textit{comparison operator} (==, !=, $<$=, $<$, $>$=, $>$) 
        \item While loop \\ 
        \textbf{while}(\textit{condition}) \textbf{do} \textit{statements} \textbf{od}
    \end{itemize}
    
    \subsection{Algebraic Data Types}
    
    In order to parse any of the statements of this simple programming language, an algebraic data type type namely \textbf{AST} needs to be created. This \textbf{AST} will provide a tree representation of the abstract structure of the programming language. The \textit{Abstract Syntax Tree} is portrayed through Haskell's algebraic data types and its implementation is illustrated below:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        data AST = DeclarationInt String Int 
                 | DeclarationString String String
                 | Print String
                 | Get String
                 | AssignmentVar String String
                 | AssignmentOp String String Operator String 
                 | WhileLoop Condition [AST] deriving (Show)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent As it can be seen, the AST is referencing two data types which have not been created yet. As a consequence, the definition of the \textbf{Operator} and \textbf{Condition} data types has been defined below: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    data Operator  = Multi | Div | Plus | Minus
                   | Equal | NotEqual
                   | GreaterThan | GreaterThanOrEqual 
                   | LessThan | LessThanOrEqual deriving (Show)
        
    data Condition = Condition String Operator String deriving (Show) 
    \end{lstlisting}
    \end{tcolorbox}
    
    \subsection{Tokenizer}
    
    An important step in order to parse the statements of our programming language is slicing input strings into fragments such as keywords, symbols and other elements called tokens. Therefore, a \textbf{tokenizer} has been built to mimic this behavior.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    tokenize         :: String -> Parse String
    tokenize []       = result []
    tokenize (x : xs) = singleChar x `bind` \first -> tokenize xs 
                              `bind` \rest  -> result (first:rest)
     \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textit{tokenizer} is eating a keyword and an input string to then return a tuple of parsed and unparsed input string. Whether the content of the input string is going to be parsed will depend on the value of the keyword which itself is also a string. Obviously, if this keyword is an empty string than nothing will be parsed no matter the content of the input string. In case, the token in a non empty string then the \textit{tokenizer} will use the \textit{singleChar} parser to parse the first character of the input string and through the bind operator pass the parsed character as an input to the lambda expression \textbf{\textbackslash first -$>$ tokenize xs}. Then, the function will recursively apply the \textit{tokenizer} to the rest of the keyword. This operation will finish when the whole keyword has been traversed. Through another bind operator, the resulting value of \textbf{tokenize xs} will be passed as an input to the lambda expression taking the \textbf{rest} variable and returning a \textit{result} parser. The \textit{result} parser takes as an input a list containing the parsed and unparsed input string which is also the output of the \textit{tokenizer}. \\ \\
    The following example will illustrate how the \textit{tokenizer} will parse the Integer keyword:
    
    \begin{center}
            \textbf{ghci$>$} tokenize \textcolor{red}{``Integer"} ``Integer a = 5" \\
             $\big[$(\textcolor{green}{``Integer"}, \textcolor{red}{`` a = 5"})$\big]$
        \end{center}
    
    \noindent Therefore, the \textit{tokenizer} will come in handy in parsing any keyword the programmer wants. In the upcoming sections, we will see how the tokenize can be used as an asset to build the parsers of each statement. 
    
    \subsection{Repetition}
    
    At the moment the isword parser
    
    \subsection{Statements}
    
    In this section, the approaches used to parse the statements of our programming language will be illustrated. Thanks to the \textit{result} parser and the \textit{bind} operator, this process has been simplified to a great extent and parsers are much more readable. 
    
    \subsubsection{Variable Declaration}
    
    The simple programming language used for this case study contains only two types of variables: \textbf{Strings} and \textbf{Integers}. The declaration of a variable contains the following format: a keyword (either \textit{String} or \textit{Integer}), a space, a variable name (list of characters), a space, an equality operator, a space, a number for integer declaration or a string surrounded in single quotes for string declaration. \\ \\
    Keeping in mind the format, the construction of the \textbf{parse\textunderscore declaration\textunderscore string} and \\ \textbf{parse\textunderscore declaration\textunderscore int} is rather straightforward since all the parsers needed to construct these parsers have already been defined on section 5.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_declaration_string :: Parse AST
    parse_declaration_string = 
        tokenize "String " `bind` \string -> isword 
                           `bind` \id -> tokenize " = "          
                           `bind` \eq -> singleChar '\''  
                           `bind` \startQuote -> isword 
                           `bind` \word -> singleChar '\''    
                           `bind` \endQuoute -> 
        result (DeclarationString id (startQuote : word ++ [endQuoute])) 
     \end{lstlisting}
    \end{tcolorbox}
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
     parse_declaration_int :: Parse AST 
     parse_declaration_int = 
        tokenize "Integer " `bind` \integer -> isword 
                            `bind` \id -> tokenize " = " 
                            `bind` \eq -> is_number 
                            `bind` \num ->
        result (DeclarationInt id (read num :: Int) ) 
     \end{lstlisting}
    \end{tcolorbox}
    
    \noindent From the above implementations, it can be seen how important the \textit{tokenizer} is by parsing groups of characters like ``\textbf{String }",``\textbf{Integer }", and ``\textbf{ = }". Additionally, binding operators combine parsers and provide a smooth transition between each one of them. The \textbf{result} parser is utilized to yield a list of tuples containing the corresponding parsed AST and unparsed input string.  
    
    
    \subsubsection{Input and Output}
    
    The behavior of input and output operations is represented with the keywords \textbf{get} and \textbf{print} respectively. The format in parsing input and output is the following: a keyword (either \textbf{get} or \textbf{print}), an opening bracket, variable name, and a closing bracket. The implementation of the parsers that will parse the input and output statements is presented below:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_get :: Parse AST
    parse_get  = tokenize "get(" `bind` \get -> isword 
                                 `bind` \var -> singleChar ')' 
                                 `bind` \close -> result (Get var) 
     \end{lstlisting}
    \end{tcolorbox}
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_print :: Parse AST
    parse_print  = tokenize "print(" `bind` \print -> isword 
                                     `bind` \var -> singleChar ')' 
                                     `bind` \close -> result (Print var) 
     \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The construction of these parsers is much simpler that the parsers from variable declaration since there is not so much tokens to parse in this situation. The \textit{tokenizer} is again used to parse the keywords together with opening bracket: \textbf{"print("} and \textbf{get(}. The outcome in both parsers contains the \textbf{result} parser taking as input the AST values \textbf{Get var} or \textbf{Print var} (where \textit{var} is the string parsed by the \textit{isword} parser) and the remaining unparsed input string.
    
    
    \subsubsection{Variable Assignment}
    
    Variable assignment will take place in two forms where the right side of the assignment can be either just a variable or a combination of two variables with a comparison or an arithmetic operator in between. The assignment format is: a variable name, a space, a colon, an equality operator, a space and the right side (a variable name or a variable name, a space, an operator, a space, another variable name). The implementation of the first case of variable assignment is presented below:  
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_assignment_var :: Parse AST
    parse_assignment_var = 
        isword `bind` \leftvar -> tokenize " := " 
               `bind` \eq -> isword 
               `bind` \rightvar -> 
        result (AssignmentVar leftvar rightvar) 
     
     \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The second case of variable assignment is not as simple as the first one since some additional parsers need to be included in order to parse operators (\textit{comparison} and \textit{arithmetic}). Each operator is represented with a different parser that has type \textbf{Parse Operator} since an \textit{Operator} data type is being parsed and not an \textit{AST} data type. Initially, the parsers for the arithmetic operators are illustrated: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_multi_op :: Parse Operator
    is_multi_op = singleChar '*' `bind` \multi -> result Multi
    
    is_div_op :: Parse Operator
    is_div_op = singleChar '/' `bind` \div -> result Div
    
    is_plus_op :: Parse Operator
    is_plus_op  = singleChar '+' `bind` \plus -> result Plus
    
    is_minus_op :: Parse Operator
    is_minus_op  = singleChar '-' `bind` \minus -> result Minus
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent As it can be seen, the design is rather simple containing a single \textbf{bind} between the \textbf{singleChar} parser and a function taking the operator character parsed and returning the \textbf{result} parser. The \textbf{result} parser is used to represent the outcome of these parsers taking one of the value constructors of \textit{Operator} which depends on the operator parsed and the remaining input string. \\ \\ 
    Next, the parsers for the \textit{comparison} operators are illustrated:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_greaterthan_op :: Parse Operator 
    is_greaterthan_op = singleChar '>' `bind` \greater -> 
                                        result GreaterThan
    
    is_greaterthan_eq_op :: Parse Operator 
    is_greaterthan_eq_op = tokenize ">=" `bind` \eq -> 
                                         result GreaterThanOrEqual
    
    is_lessthan_op :: Parse Operator 
    is_lessthan_op = singleChar '<' `bind` \less ->
                                      result LessThan
    
    is_lessthan_eq_op :: Parse Operator 
    is_lessthan_eq_op = tokenize "<=" `bind` \eq -> 
                                      result LessThanOrEqual
    
    is_eq_op :: Parse Operator
    is_eq_op = tokenize "==" `bind` \eq2 -> result Equal
    
    is_not_eq_op :: Parse Operator
    is_not_eq_op = tokenize "!=" `bind` \eq -> result NotEqual
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent As expected, the construction is equivalent to the \textit{arithmetic} parsers. Although, on the operators (==, !=, $<$=, $>$=) a \textit{tokenizer} is used since more than one character needs to be recognized to then be parsed. \\ \\
    At the moment, all the parsers to recognize \textit{arithmetic} and \textit{comparison} operators have been defined. The next step would be creating another parser that encapsulates all of the above parsers to recognize operators in general. How can this be achieved? Well, with the elegance of \textit{alternation} of course! However, before creating the final is\textunderscore operator parser, two parsers to wrap arithmetic and comparison operator separated needs to be defined. Let's see how nice and neat these parsers looks like:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_arith_op :: Parse Operator 
    is_arith_op = is_multi_op +++ is_div_op 
                  +++ is_plus_op +++ is_minus_op
                  
    is_comp_op :: Parse Operator
    is_comp_op = is_greaterthan_eq_op +++ is_greaterthan_op 
                 +++ is_lessthan_eq_op +++ is_lessthan_op 
                 +++ is_eq_op +++ is_not_eq_op
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent In the \textbf{is\textunderscore comp\textunderscore op} parser the order of the ($<$=, $<$) and ($>=$, $>$) parsers is very important since the monadic \textit{alternation} operator will compute the next parser only if the previous parser fails. Lets suppose that the \textbf{is\textunderscore greaterthan\textunderscore op} parser precedes the \textbf{is\textunderscore greaterthan\textunderscore eq\textunderscore op} parser in the alternation chain. As a consequence, the ($>$=) operator will never be parsed. Why? If the \textbf{is\textunderscore comp\textunderscore op} tries to parse the input string $>$=, then the \textbf{is\textunderscore greaterthan\textunderscore eq\textunderscore op} will be computed by succeeding in parsing just $>$ and ignoring any parser that follows.
    
    \begin{center}
            \textbf{ghci$>$} is\textunderscore comp\textunderscore op \textcolor{red}{``$>$="} \\
             $\big[$(\textcolor{green}{``GreaterThan"}, \textcolor{red}{``="})$\big]$
        \end{center}
    
    \noindent The same situation applies to the ($<$=, $<$) combination. Therefore, order is important between these operators. \\ \\ 
    After cleariing this ambiguity is safe to create the final \textbf{is\textunderscore operator} parser which will alternate between the \textit{arithmetic} and \textit{comparison} operator parsers where order will not matter. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_operator :: Parse Operator 
    is_operator = is_arith_op +++ is_comp_op
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The creation of the \textbf{is\textunderscore operator} parser makes it viable to finally build the variable assignment parser where the right side contains an operator between two variable names. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_assignment_op :: Parse AST
    parse_assignment_op  = isword `bind` \leftvar -> tokenize " := " 
                                  `bind` \eq -> isword 
                                  `bind` \leftopvar -> singleChar ' ' 
                                  `bind` \space2 -> is_operator 
                                  `bind` \operator -> singleChar ' ' 
                                  `bind` \space3 -> isword 
                                  `bind` \rightopvar -> 
        result (AssignmentOp leftvar leftopvar operator rightopvar)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent Several \textbf{bind} operators have been used to construct this parser showing how the concept of monadic \textit{sequencing} keeps the steps transparent and provides a smooth transition between the different parsers used.  
    \subsubsection{While Loop}
    
    \subsection{Combining Statements}
    
    \subsection{Parsing a program}
    
    
    
    
    \begin{thebibliography}{9}
    \bibitem{categorytheory} 
    M. D. Hill, Jonathan & Clarke, Keith. (1994). \textit{An Introduction to Category Theory, Category Theory Monads, and Their Relationship to Functional Programming}.
    \bibitem{essenceFP}
    Wadler, P. (1992b). \textit{The essence of functional programming. In
    20th ACM Symposium on Principles of Programming Languages}
    (POPL’92), pages 1–14. ACM, Albuquerque.
    \bibitem{original}
    Walder, P. \textit{Monads for functional programming}, section 5.2. University of Glasgow. 
    \bibitem{pearls}
    Hutton, G. and Meijer, E. \textit{Monadic Parsing in Haskell}. University of Nottingham.
    \bibitem{bringMonadComprehension}
    Giorgidze. G, Grust. T, Schweinsberg. N, and Weijers. J. \textit{Bring Back Monad Comprehensions}. Wilhelm-Schickard-Institut fur Informatik and Eberhard Karls Universitat Tubingen.
    \end{thebibliography}
    \end{document}
    