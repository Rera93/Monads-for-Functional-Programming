\documentclass[a4paper, onecolumn]{article}
    \usepackage[utf8]{inputenc}
    \usepackage{blindtext}
    \usepackage{cite}
    \usepackage{comment}
    \usepackage{color}
    \usepackage{listings}
    \usepackage{tcolorbox}
    \usepackage[a4paper,left=2.9cm,right=2.9cm,top=4cm,bottom=4cm]{geometry}
    
    \title{\Large{Research Seminar Software Science} \\
    \huge{Simulation of monadic effects in Haskell}}
    \author{Brigel Pineti}
    \date{April 2018}
    
    \begin{document}
    
    \maketitle
    
    \section*{Abstract}
    
    TODO: Write once the paper is coming to an end!
    
    \section{Introduction}
    
    Pure function languages like Haskell rule out side effects. Why? Firstly, to allow unrestricted application of program transformation and equation logic. Secondly, being a non-strict language, Haskell's order of side effects is undefined. The aim of this paper is to show how monads can be used to capture impure effects into a pure language. The code snippets attached to this paper are implemented in Haskell. Section 2 will provide an overview on the characteristics of the language being used. Section 3 describes the construction of a monad, the various monadic flavors and the Maybe Monad as an illustrative example to get the reader's feet wet with the complex concept of a Monadic value. The application of monads is demonstrated with one case study to construct recursive decent parsers. \textit{(more cases studies to be added on next intermediate presentation)} 
    
    \section{Haskell}
    
    In this section are reflected two main features concerning the above mentioned functional language. Taking into consideration that not every reader might be familiar with the properties of the language, I found it necessary to briefly illustrate the laziness and purity of Haskell.  
    
    \subsection{Lazy Evaluation}
    
    Haskell is a functional language with non-strict semantics. What does this mean? An expression is evaluated from the outside in. For instance, the evaluation of \textit{$(a + (b * c))$} will firstly reduce the \textit{$+$} operator and then the inner bracket \textit{$(a * b)$}. \\
    Lazy evaluation is just an implementation approach for a non-strict language. An appropriate definition for laziness can be represented by the term \textit{call-by-need}. Consequently, the evaluation of an expression is delayed until its result is actually needed from another computation. Therefore, the parameters of a function are evaluated only when they are needed and not a moment before.
    
    \subsection{Absence of Side Effects}
    
    A straightforward consequence of laziness is the evaluation order of a Haskell program. Being demand-driven, it becomes impossible for a function call to produce any side effects. Therefore, Haskell is considered to be a \textit{pure language}. For example, a function of type $Char \rightarrow Char$ will neither write nor read any mutable variables. Nevertheless, side effects are without any doubt very convenient. Haskell's restricted side effects resulted in a sluggish input/output. For this reason, monadic I/O was created; thus by leading to a functional language with side effects. 
    \section{Monads}
    Monads originate from a section of mathematics called category theory \cite{categorytheory}. Luckily for the inexperienced readers, it is not required to have prior knowledge in category theory in order to comprehend the application of monads in Haskell. 
    Nevertheless, there exists a certain complexity when it comes to grasping to concept of a monad. From history, monads were initially adopted in Haskell to produce input and output operations. However, the capabilities of monads were not bound to just I/O. Additionally, monads can support multiple operations such as state, non-determinism, continuations, exceptions etc.
    \subsection{Construction}
    For now think of a monad as a way of chaining operations together. 
    In order to have a monad, three components are essential to its construction: 
    \begin{itemize}
        \item a type constructor
        \item a function return
        \item a bind operator ($\gg$=)
    \end{itemize}
    The \textit{return} function and the bind operator ($\gg$=) have the following types: 
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
       return :: a -> M a 
       (>>=)  :: M a -> (a -> M b) -> M b 
      \end{lstlisting}
    \end{tcolorbox}
    In order for the above function definitions to hold, the monad laws need to be satisfied. There exist three monadic laws as presented below: 
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
    right unit             m >>= return  =  m 
    left  unit      return x >>= f       =  f x   
    associative    (m >>= f) >>= g       =  m >>= (\x -> f x >>= g) 
      \end{lstlisting}
    \end{tcolorbox}
    
    According to the laws of right and left unit, the return serves as a collector of a value where no computation occurs. As the type of \textit{return} suggests, it takes a value of type \textit{a}, puts it in a special context \textit{m} and returns as a result \textit{m a}. Furthermore, the associative law guarantees that the bind operator ($\gg$=) is concerned only with the order of computation and not on the manner the operators are nested together. The bind operation can be compared to a semicolon(;) by taking the output from the former step and feeding it to the next step.
    \subsection{Flavors}
    
    It is crucial to understand that there exist more than one kind of monad. As a result, the implementation of the bind function ($\gg$=) mentioned on the previous section differs on various monads. 
    
    \begin{itemize}
        \item \textbf{Fail Monad} - Consider the case that each step will \textit{return} either a success or a fail. The bind operator can be constructed in such a way that the next step will be executed only if the former step succeeds. Hence, there is no need to check if the previous step failed since the \textit{fail monad} will take care of this by automatically aborting in case of a former failing step.
        \begin{center}
            \textbf{data} Failure \textit{a} = Fail $\vert$ Success \textit{a} 
        \end{center}
        \item \textbf{Exception Monad} - Either returns a values or raises an exception. Since it is up to the developer to implement such a monad, he/she may decide to ignore the first exception and throw an exception only if a second one is found. 
        \begin{center}
            \textbf{data} Exc \textit{e a} = Exception \textit{e} $\vert$ OK \textit{a}
        \end{center}
        \item \textbf{List Monad} - Models non-deterministic computation and return a sequence of values. There exists the opportunity to program each step to return multiple values. The bind operator ($\gg$=) may be used to iterate over these values and pass each value to the upcoming step. Otherwise various loops would be needed to deal with all these results. As it can be seen, the bind operator of the list monad would be very beneficial by removing the complexity of adding loops to retrieve information. 
        \begin{center}
            \textbf{type} List \textit{a} = [\textit{a}]
        \end{center}
        \item \textbf{State Reader Monad} - Accepts a state as an input and reads a value of type \textit{a} without performing any computation on the state itself. The bind operator can be used to pass additional data with the sole purpose to access it from anywhere without the necessity to manually pass data to every step in order to read it. 
        \begin{center}
            \textbf{type} SR \textit{s a} = \textit{s} $\rightarrow$ \textit{a}
        \end{center}
        \item \textbf{State Transformer Monad} - Mainly used to thread the state during program execution. The transformer takes the old state as an input and returns a tuple of the value of type \textit{a} and the new state. Additionally, the state transformer is perfect for simulating update operations.
        \begin{center}
            \textbf{type} ST \textit{s a} = \textit{s} $\rightarrow$ (\textit{a}, \textit{s})
        \end{center}
        \item \textbf{Parser Monad} - Extremely helpful in modeling parsers. The input is a String to be parsed and the output is a list containing the parsed value of type \textit{a} and the remaining unparsed String. The list represents all the possible parses of the input String; being empty if nothing is parsed, having only one parse if there is one parse and so on. The parser monad is equivalent to the combination between the list monad and the state transformer monad.  
        \begin{center}
            \textbf{type} Parser \textit{a} = String $\rightarrow$ [(\textit{a}, String)] 
        \end{center}
    \end{itemize}
    It is thought-provoking how any type can act as a \textit{Monad} just by defining some functions that comply with the three monadic laws in order to guarantee that the composition of functions with side effects is \textit{associative} and has an \textit{identity} \cite{essenceFP}.
    
    \subsection{Maybe}
    The Maybe monad has been selected to provide a concrete insight on how a monad works in practice. The nature of Maybe provides a smooth solution to situations where some function may or may not return a value. The type constructor is presented below:
    
    \begin{center}
        \textbf{data} Maybe \textit{a} = Just \textit{a} $\vert$ Nothing 
    \end{center}
    The Maybe type constructor suggests that for any value of type \textit{a}, it returns either \textit{Just} that value or \textit{Nothing}. The \textit{return} and ($\gg$=) are defined like this:
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
        return :: a -> Maybe a
        return x     = Just x 
    \end{lstlisting}
    \end{tcolorbox}
    The \textbf{return} will take as an input a normal value and place it inside the context of a Maybe value. In this case, it is placed inside the \textbf{Just} value constructor. For example: 
    
    \begin{center}
        ghci$>$ \textbf{return} \textit{``hello"}
    \end{center}
    The resulting value of the above operation will be \textbf{Just} \textit{``hello"}.
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
        (>>=) :: Maybe a -> (\a -> Maybe b) -> Maybe b
        Nothing >>= f = Nothing
        Just x  >>= f = f x
    \end{lstlisting}
    \end{tcolorbox}
    The binding operator ($\gg$=) takes \textbf{Maybe a} and a function of type \textbf{a $\rightarrow$ Maybe b} and somehow applies the function to \textbf{Maybe a} in order to return \textbf{Maybe b}. An example might be useful to illustrate this: 
    \begin{center}
    ghci$>$ \textbf{Just} \textit{``smile"} $\gg=$ \textbackslash x $\rightarrow$ \textbf{Just} (\textit{x} ++ \textit{`` :)"})
    \end{center}
    When the function is applied to \textbf{Just ``smile"}, it removes \textbf{``smile"} from its special context and passes it as an input to the function \textbf{\textbackslash x $\rightarrow$ Just (x ++ `` :)")}.  The function will return \textbf{Just ``smile :)"}. This is what I call magic! On the other hand, replacing \textbf{Just ``smile"} with the value constructor \textbf{Nothing} will always result in \textbf{Nothing} being independent from the function \textbf{f}.
    
    
    \subsection{Conclusions}
    A monad is helpful in chaining various computations together and managing how that chain of action functions as a unit. In addition, the monadic laws will be in charge of supervising two imperative cases:
    
    \begin{itemize}
        \item state between actions by guaranteeing that they are executed in the appropriate order 
        \item failing situations by ensuring that upcoming actions are aborted and the whole expression is evaluated to a failure
    \end{itemize}
    Therefore, it is essential to understand how the Maybe types work as a Monad in order to then comprehend more complicated Monads like \textit{State} and \textit{IO}.
    
    \section{Lists}
    This section shows how the monadic behaviour of lists can be used in our advantage to explicitly demonstrate non-determinism. \\ \\
    In general, lists can be both \textit{deterministic} and \textit{non-deterministic}. For instance, take into consideration a list containing just one element \textbf{[27]}. Clearly, the former list is deterministic since it accommodates a single value and it is apparent that the value equals to 27. On the other hand, a list enclosing more than one element \textbf{[27, 6, 21]} introduces non-deterministic behaviour since it can have many outcomes at the same time. \\ \\
    The notion of \textit{non-determinism} can be decoded smoothly in monadic terms. Below is illustrate how the Monad instance is defined for a list: \\
    \begin{lstlisting}[language=Haskell]
        instance Monad [] where
            return x = [x]
            xs >>= f = concat (map f xs)
    \end{lstlisting} 
    The \textbf{return} wraps a values of type \textit{x} and places it into the special context of a list. In other words, it creates a list that contains only that single value. Afterwards, this not so simple value anymore can interact with other values to produce a non-deterministic nature.   \\ \\
    The bind operator \textbf{($>>$=)} is taking a monadic list, removing its elements from the monadic context and feeding them into a function that takes normal values and returns again monadic list.  In order to remove the confusion, the example below can be used to clarify the complexity of the bind operator: \\
    \begin{lstlisting}[language=Haskell]
       ghci> [3, 6, 10] >>= \x -> [x, 2*x]
       [3, 6, 6, 12, 10, 20]
    \end{lstlisting} \\
    Therefore, the purpose of the bind operator is to facilitate the non-deterministic attitude of lists. \textbf{[3, 6, 10]} is a non-deterministic list that is being feed into a function that itself returns a non-deterministic list. Hence, the final result will be a non-deterministic list containing all the possible combinations between the elements of the list \textbf{[3, 6, 10]} and the passing of these values to the function \textbf{\textbackslash x $\rightarrow$ [x, 2*x]}. The job of the function is straightforward. The function generates two outcomes for each element of the input list, the original value and the value multiplied by 2. 
    
    
    
    \section{Parsers}
    Monads are valuable in modeling sequencing and alternation in recursive decent parsers. The methods described in this section are extensible since parsers are treated as first-class values and combinators are defined in Haskell. Additionally, it portrays the purity of functional programming.
    
    \subsection{State Transformers}
    
    Parsers in functional programming are pictured as state transformers \cite{original}. Recall state transformers monads from section 3.2.  
    
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
      type Parse p = State -> [(p, State)]
      type State    = String  
      
      \end{lstlisting}
    \end{tcolorbox}
    
    The parser of type \textit{p} takes a state represented as a string ready to be parsed and returns a list containing the value of type \textit{p} parsed from the string and a state represented again as a string that is yet to be parsed. Since a parser may not consume all of its input string, the unconsumed suffix of the input must be returned along with the prefix of the input. As a result, the outcome of a parser must be a list enclosing consumed and unconsumed part of the input string. Additionally, the case when an empty list is returned is treated as a failure \cite{pearls}. On the other hand, an non-empty list is marked as a success. Lets take into consideration a straightforward parser for multiplication operations.
    
    \begin{center}
        \textbf{data} Expr = Const \textit{Int} $\vert$ Multi \textit{Expr} \textit{Expr} 
    \end{center}
    
    Next, lets create a parser of type Expr. 
    
    \begin{center}
        parseExpr :: \textbf{Parse} \textit{Expr} 
    \end{center}
    
    The following examples take as input the state defined as a string. 
    
    \begin{lstlisting}[language=Haskell]
        parseExpr "27 or twentyseven" = [(Const 27, " or twentyseven")] 
        parseExpr "twentyseven"       = []
    \end{lstlisting}
    
    For simplicity, the focus will remain on parsers that either fail and return an empty list of results, or succeed and return a singleton list.
    
    \subsection{Primitive Parsers}
    
    This subsection will introduce three primitive parsers with the sole purpose to achieve diverse parser combinators. \\ \\
    Firstly, the parser oneItem will fail if the input provided is an empty list. Otherwise, it will eat only the first character of the input string and leave the other part of the input unconsumed. This parser is defined by applying pattern matching on the list. 
     
    
    \begin{lstlisting}[language=Haskell]
      oneItem         :: Parse Char
      oneItem []       = []
      oneItem (l : ls) = [(l, ls)]
    \end{lstlisting}
    
    To better illustrate follow the examples below that treat both cases.
    
    \begin{lstlisting}[language=Haskell]
      oneItem ""       = []
      oneItem "parser" = [('p', "arser")]
    \end{lstlisting}
    Secondly, the parser \textbf{zero} will always fail, regardless of the input string provided. 
    
    \begin{lstlisting}[language=Haskell]
      zero :: Parse p
      zero = \input -> [] 
    \end{lstlisting}
    
    In other words, the outcome of the \textbf{zero} parser will always be an empty list. \\ \\
    Finally, the \textbf{result v} parser will always succeed by returning the value \textit{v} without consuming any input.
    
    \begin{lstlisting}[language=Haskell]
      result :: p -> Parse p
      result v input = [(v, input)]
    \end{lstlisting}
    
    \subsection{Parser Combinators}
    
    The three primitive parsers that were defined in the previous subsection aren't very helpful when used separately. Hence, these parsers have to be combined together through some operators in order to actually produce something useful. In this subsection, two operators are introduced: \textit{sequence} and \textit{alternation}. 
    
    \subsubsection{Sequencing}
    
    Sequencing of parsers is usually captured by a combinator called \textit{seq} where two parsers are applied one after another with the result from the two parsers being combined together as a tuple. The example below will illustrate the definition of the \textit{seq} operator:
    
    \begin{tcolorbox}
    
    \begin{lstlisting}[language=Haskell]
      seq :: Parse a -> Parse b -> Parser (a, b)
      p `seq` q = \input -> [((v, u), input'') | (v, input') <- p input,
                                                (u, input'') <- q input']
    \end{lstlisting}
    \end{tcolorbox}
    
    In order to define the \textit{seq} operator, list comprehensions come in handy. Initially, the right side of the vertical bar is executed. In case, the parser \textbf{p} takes a non-empty \textbf{input} string, then a list of pairs will be returned accommodating the consumed prefix of the \textbf{input} and the unconsumed suffix of the \textbf{input}. The resulting list of pairs for the parser \textbf{p input} is \textbf{(v, input')}. \\ \\ Immediately after the parser \textbf{p} has accomplished it's goal, the parser \textbf{q} will take as an input string the un-parsed string from the former parser. In other words, the parser \textbf{q} takes as an input string the string \textbf{input'}. The outcome of the parser \textbf{q input'} will be the list of pairs \textbf{(w, input'')} where \textbf{u} is the \textit{prefix of the input'} and \textbf{input''} is the \textit{suffix of the input'}. \\ \\
    As a last step (the left side of the vertical bar), the parser combinator \textbf{seq} will sew together the values \textbf{u} and \textbf{v} into a tuple and return a list of pairs like \textbf{[((v, u), input'')]}. \\ \\
    In the above situation, the operator \textbf{seq} will continuously nest tuples together thus be increasing complexity and making it painful to handle. \\ \\
    The headache introduced by the nested tuples can be smoothly averted by adopting monadic sequencing. In order to achieve this type of sequencing the bind operator has been defined. The type of this operator resembles with the type of the bind operator from monad instance \textit{m}. Recalling from the section 3.1 of Monad Construction, the type of ($>>$=) was {\textbf{m a $\rightarrow$ (a $\rightarrow$ m b) $\rightarrow$ m b}}. In the monadic sequencing case, the \textit{m} is being replaced with \textit{Parse}.
    
    \begin{tcolorbox}
    
    \begin{lstlisting}[language=Haskell]
      bind :: Parse a -> (a -> Parse b) -> Parser b
      p `bind` f = \input -> concat [f v input' | (v, input') <- p input]
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{bind} combinator is an infix operator that take a parser from the left side and a function that itself takes a normal value and returns another parser from the right side. The infix \textbf{bind} is defined as a lambda expression taking a string as an input and producing a concatenation of the values parsed by the sequencing of parsers. \\ \\
    At first, the parser \textbf{p} is applied to the input string and results in a list of pairs \textbf{(v, input')} where \textit{v} is the first item exhausted by the parser \textbf{p} and the \textit{input'} is the remaining input string. \\ \\
    Now, the function \textbf{f} applies to the normal value \textbf{v} to form a parser \textbf{f v} which is afterwards applied the string \textbf{input'}. The resulting parser will be a list of concatenated lists. The examples below will help in clarifying any confusion being raised by the \textbf{bind} operator. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseOneItem :: Parse Char
      parseOneItem  = oneItem `bind` \x -> result x 
    \end{lstlisting}
    \end{tcolorbox}
    
    The parser \textbf{parseOneItem} produces that same result as the primitive parser \textbf{oneItem} defined in section 5.2 but their implementation differs. The latter parser is using the former parser in its definition. \\ \\ 
    In practice, the \textbf{oneItem} parser is consuming the first character of an input string and through the \textbf{bind} operator this value is being passed as an input to the lambda function expression \textbf{\textbackslash x $\rightarrow$ result x}. Furthermore, this function is returning the primitive \textbf{result} parser. From section 5.2, the \textbf{result} parser will always succeed by returning the value x that was passed to it without exhausting any input string. In this case, the goal of the \textbf{result} parser is to just display what was parsed and what was not parsed, and doesn't need to worry about parsing since the \textbf{oneItem} parser is taking care of that.  
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseTwoItems :: Parse (Char, Char)
      parseTwoItems  = oneItem `bind` \x -> oneitem 
                               `bind` \y -> result (x, y)
    \end{lstlisting}
    \end{tcolorbox}
    
    The parse \textbf{parseTwoItems} manages to parse the first two characters of the input string and returns the two parsed characters and remaining part of the input string which is not yet parsed. \\ \\
    In practice, the \textbf{parseTwoItems} is using two \textit{bind} infix operators. In the first \textit{bind}, the \textbf{oneItem} parser is eating the first character of the input string and passing the corresponding value to the function \textbf{\textbackslash x $\rightarrow$ oneItem}, which differently from the previous \textbf{parseOneItem} parser is returning another \textbf{oneItem} parser instead of the primitive \textbf{result} parser. In the second \textit{bind}, the  other \textbf{oneItem} parser is devouring the first character of the unparsed input string and passing that value as an input to the function \textbf{\textbackslash y $\rightarrow$ result(x, y)}. Finally, the resulting output will be handled by the \textbf{result} parser which will return the values of \textit{x} and \textit{y} being correspondingly the first and the second character of initial input string, together with the unparsed input string as a tuple. \\ \\ 
    The following example will better illustrate the outcome when parsing a string:
       \begin{center}
            \textbf{ghci$>$} parseTwoItems \textcolor{red}{``rera"} \\
            $\big[$((\textcolor{green}{`r'}, \textcolor{green}{`e'}), \textcolor{red}{``ra"})$\big]$
        \end{center}
        
    From the above example, it can be deduced that the outcome of the first parser can be sequentially consumed by the second parser and so on if other parsers are included. Hence, the \textit{bind} infix operator will dodge the complication introduced by the nested tuples. Consequently, the \textit{seq} can be defined using the \textit{bind} operator: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      p `seq` q = p `bind` \x -> q `bind` \y -> result (x, y)
    \end{lstlisting}
    \end{tcolorbox}
    
    The monadic \textit{bind} operator can be used to define parsers of a different nature. For example, a \textbf{satisfy} combinator may be constructed as a function that takes a predicate as input and returns a parser that consumes the first element of a string if the predicate is true and fails if the predicate is false. In order to fulfill the required parsing behavior, the primitive parsers \textit{oneItem}, \textit{result} and \textit{zero} mentioned in section 5.2 are necessary. Let's observe how the \textbf{satisfy} can be implemented: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      satisfy :: (Char -> Bool) -> Parse Char
      satisfy pred = oneItem `bind` \x -> if pred x 
                                          then result x 
                                          else zero
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{satisfy} combinator will initially parse the first item of the input provided. Afterwards, through the \textit{bind} operator this value is passed as an input to the function taking the first character as an input and returning an if statement as an output. The if statement checks what the predicate returns. If the predicate is true the first value parsed and the unparsed input string are returned through the \textbf{result} parser, otherwise the parser will fail and will return an empty list through the \textbf{zero} parser.  \\ \\
    A benefit of using the monadic approach to define parsers is the support provided by the \textit{monad comprehension syntax} \cite{bringMonadComprehension}. Monad comprehensions will promote readability of parsers. Hence, the satisfy can be transformed into the following structure: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      satisfy pred = [x | x <- oneItem, pred x]
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{satisfy} parser combinator can be easily extended to add precision in parsers. Hence, parsers like \textbf{singleChar}, \textbf{isdigit}. \textbf{islowercase} and \textbf{isuppercase} can be defined:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      singleChar   :: Char -> Parse Char
      singleChar a  = satisfy (\b -> a == b)
      
      isdigit :: Parse Char
      isdigit  = satisfy (\a -> a >= '0' && a <= '9')
      
      islowercase :: Parse Char
      islowercase  = satisfy (\a -> a >= 'a' && a <= 'z')
      
      isuppercase :: Parse Char 
      isuppercase  = satisfy (\a -> a >= 'A' && a <= 'Z')
    \end{lstlisting}
    \end{tcolorbox}
    
    The names for each parser are speaking for themselves. Each of the above parsers will success in parsing the first character if the predicate takes an input for the satisfy combinator is true. On the other hand, the parser will fail and return [ ]. 
    
    In conclusion, it is very important to comprehend that the monadic \textbf{bind} made possible the creation of \textbf{satisfy} and what followed as an extension of \textbf{satisfy}. However, this is not the end of the commodity that the \textbf{bind} operator provides. For instance, a new parser may be created to parse two digits or more if the predicate holds or to fail if it doesn't. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseTwoDigits :: Parse (Char, Char)
      parseTwoDigits  = isdigit `bind` \x -> isdigit 
                                `bind` \y -> result(x,y)
    \end{lstlisting}
    \end{tcolorbox}
    
    Applying this parser to an input string ``12rera" will succeed with the result [((`1', `2'), ``rera")] whereas in case of an input ``1rera" will fail and return [ ] since the second parsed character \textit{`r'} is not a digit. \\ \\
    Nevertheless, it would not be convenient to create new parsers each time more items need to be parsed. For that reason, \textit{recursive parsers} are desired. Additionally, recursive operation must be terminated at some point. In order to achieve or not termination, the \textbf{alternation} combinator has to be used but more on that on the next subsection.
    \subsubsection{Alternation}
    
    In this subsection, the attention will be redirected towards producing alternation in parsers.  The implementation of 2 parsers being alternated together will be represented by the operator (\texttt{+++}) and we will refer to this as the \textbf{plus} parser. Have a look at the following Haskell snippet to understand how alternation is attained:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      (+++) :: Parse a -> Parse a -> Parse a
      p +++ q  = \input -> (p input ++ q input)
    \end{lstlisting}
    \end{tcolorbox}
    \noindent The nature of the plus parser can be illustrated by defining the \textbf{islower\_r} parser which alternated two of the already defined parsers from the previous subsection: \textbf{islowercase} and \textbf{singleChar}.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        islower_r :: Parse Char
        islower_r  = islowercase +++ singleChar `r'
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent Now, let's apply the \textbf{islower\_r} parser to an input string that contains `r' as it's first character.
    
    \begin{center}
            \textbf{ghci$>$} islower\_r \textcolor{red}{``rera"} \\
            $\big[$(\textcolor{green}{`r'}, \textcolor{red}{``era"}), (\textcolor{green}{`r'}, \textcolor{red}{``era"})$\big]$
        \end{center}
    
     \noindent The \textbf{islower\_r} parser is producing duplicates inside the list while just one of the duplicates is necessary to be displayed. At the moment, even though the first parser will succeed in parsing the input, the second parser will always be applied to the same input.This is not the desired behaviour from alternation of parsers. The goal is to allow the second parser to parse the input string only if the initial parser has failed in doing so. Additionally, if the first parser succeeds in parsing the input, the program is terminated and the parsed result is returned. How can the \textbf{plus} parser be altered so that it can introduce this deterministic behavior? \\ \\ 
     
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        p +++ q = \input -> case p input of
                              [(val, input')] -> [(val, input')]
                                           [] -> q input
    \end{lstlisting}
    \end{tcolorbox}
     
     
    
    
    \subsection{Conclusions}
    
    
    \begin{thebibliography}{9}
    \bibitem{categorytheory} 
    M. D. Hill, Jonathan & Clarke, Keith. (1994). \textit{An Introduction to Category Theory, Category Theory Monads, and Their Relationship to Functional Programming}.
    \bibitem{essenceFP}
    Wadler, P. (1992b). \textit{The essence of functional programming. In
    20th ACM Symposium on Principles of Programming Languages}
    (POPL’92), pages 1–14. ACM, Albuquerque.
    \bibitem{original}
    Walder, P. \textit{Monads for functional programming}, section 5.2. University of Glasgow. 
    \bibitem{pearls}
    Hutton, G. and Meijer, E. \textit{Monadic Parsing in Haskell}. University of Nottingham.
    \bibitem{bringMonadComprehension}
    Giorgidze. G, Grust. T, Schweinsberg. N, and Weijers. J. \textit{Bring Back Monad Comprehensions}. Wilhelm-Schickard-Institut fur Informatik and Eberhard Karls Universitat Tubingen.
    \end{thebibliography}
    \end{document}
    