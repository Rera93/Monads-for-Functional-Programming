\documentclass[a4paper, onecolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{blindtext}
\usepackage{cite}
\usepackage{comment}
\usepackage{color}
\usepackage[a4paper,left=3cm,right=3cm,top=4cm,bottom=4cm]{geometry}

\title{\Large{Research Seminar Software Science} \\
\huge{Simulation of monadic effects in Haskell}}
\author{Brigel Pineti}
\date{April 2018}

\begin{document}

\maketitle

\section*{Abstract}

\section{Introduction}

Pure function languages like Haskell rule out side effects. Why? Firstly, to allow unrestricted application of program transformation and equation logic. Secondly, being a non-strict language, Haskell's order of side effects is undefined. The aim of this paper is to show how monads can be used to exploit impure effects into a pure language. The code snippets attached to this paper are implemented in Haskell. Section 2 will provide an overview on the characteristics of the language being used. Section 3 is using the Maybe Monad as an illustrative example to get the reader's feet wet with the complex concept of a Monadic value. The application of monads is demonstrated with three case studies.

\section{Haskell}

In this section are reflected two main features concerning the above mentioned functional language. Taking into consideration that not every reader might be familiar with the properties of the language, I found it necessary to briefly illustrate the laziness and purity of Haskell.  

\subsection{Lazy Evaluation}

Haskell is a functional language with non-strict semantics. What does this mean? An expression is evaluated from the outside in. For instance, the evaluation of \textit{$(a + (b * c))$} will firstly reduce the \textit{$+$} operator and then the inner bracket \textit{$(a * b)$}. \\
Lazy evaluation is just an implementation approach for a non-strict language. An appropriate definition for laziness can be represented by the term \textit{call-by-need}. Consequently, the evaluation of an expression is delayed until its result is actually needed from another computation. Therefore, the parameters of a function are evaluated only when they are needed and not a moment before. An advantage of laziness 

\subsection{Absence of Side Effects}

A straightforward consequence of laziness is the evaluation order of a Haskell program. Being demand-driven, it becomes impossible for a function call to produce any side effects. Therefore, Haskell is considered to be a \textit{pure language}. For example, a function of type $Char \rightarrow Char$ will neither write nor read any mutable variables. Nevertheless, side effects are without any doubt very convenient. Haskell's restricted side effects resulted in a sluggish input/output. For this reason, monadic I/O was created; thus by leading to a functional language with side effects. 
\section{Monads}
Monads originate from a section of mathematics called category theory. Luckily for us, it is not required to have prior knowledge in category theory in order to comprehend the application of monads in Haskell. 
Nevertheless, there exists a certain complexity when it comes to grasping to concept of a monad. From history, monads were initially adopted in Haskell to produce input and output operations. However, the capabilities of monads were not bound to just I/O. Additionally, monads can support multiple operations such as state, non-determinism, continuations, exceptions etc.
\subsection{Construction}
For now think of a monad as a way of chaining operations together. 
In order to have a monad, three components are essential to its construction: 
\begin{itemize}
    \item a type constructor
    \item a function return
    \item a bind operator ($\gg$=)
\end{itemize}
The \textit{return} function and the bind operator ($\gg$=) have the following types: 

\begin{center}
   return   :: a $\rightarrow$ M a \\
   ($\gg$=) :: M a $\rightarrow$ (a $\rightarrow$ M b) $\rightarrow$ M b 
   \end{center}
In order for the above function definitions to hold, the monad laws need to be satisfied. There exist three monadic laws as presented below: 

\begin{itemize}
    \item right unit \hspace{20mm} m $\gg$= return \textcolor{red}{=} m 
    \item left unit \hspace{20mm} return x $\gg$= f \textcolor{red}{=} f x   
    \item associative \hspace{15mm} (m $\gg$= f) $\gg$= g \textcolor{red}{=} m $\gg$= (\textbackslash x $\rightarrow$ f x $\gg$= g) 
\end{itemize}
According to the laws of right and left unit, the return serves as a collector of a value where no computation occurs. As the type of \textit{return} suggests, it takes a value of type \textit{a}, puts it in a special context \textit{m} and returns as a result \textit{m a}. Furthermore, the associative law guarantees that the bind operator ($\gg$=) is concerned only with the order of computation and not the manner they are nested together. The bind operation can be compared to a semicolon(;) by taking the output from the former step and feeding it to the next step.
\subsection{Flavors}

It is crucial to understand that there exist more than one kind of monad. As a result, the implementation of the bind function ($\gg$=) mentioned on the previous section differs on various monads. 

\begin{itemize}
    \item \textbf{Fail Monad} - Consider the case that each step will \textit{return} either a success or a fail. The bind operator can be constructed in such a way that the next step will be executed only if the former step succeeds. Hence, there is no need to check if the previous step failed since the \textit{fail monad} will take care of this by automatically aborting in case of a former failing step.
    \begin{center}
        \textbf{data} Failure \textit{a} = Fail $\vert$ Success \textit{a} 
    \end{center}
    \item \textbf{Exception Monad} - Either returns a values or raises an exception. Since it is up to the developer to implement such a monad, he/she may decide to ignore the first exception and throw an exception only if a second one is found. 
    \begin{center}
        \textbf{data} Exc \textit{e a} = Exception \textit{e} $\vert$ OK \textit{a}
    \end{center}
    \item \textbf{List Monad} - Models non-deterministic computation and return a sequence of values. There exists the opportunity to program each step to return multiple values. The bind operator ($\gg$=) may be used to iterate over these values and pass each value to the upcoming step. Otherwise various loops would be needed to deal with all these results. As it can be seen, the bind operator of the list monad would be very beneficial by removing the complexity of adding loops to retrieve information. 
    \begin{center}
        \textbf{type} List \textit{a} = [\textit{a}]
    \end{center}
    \item \textbf{State Reader Monad} - Accepts a state as an input and reads a value of type \textit{a} without performing any computation on the state itself. The bind operator can be used to pass additional data with the sole purpose to access it from anywhere without the necessity to manually pass to every step in order to read it. 
    \begin{center}
        \textbf{type} SR \textit{s a} = \textit{s} $\rightarrow$ \textit{a}
    \end{center}
    \item \textbf{State Transformer Monad} - Mainly used to thread the state during program execution. The transformer takes the old state as an input and returns a tuple of the value of type \textit{a} and the new state. Additionally, the state transformer is perfect for simulating update operations.
    \begin{center}
        \textbf{type} ST \textit{s a} = \textit{s} $\rightarrow$ (\textit{a}, \textit{s})
    \end{center}
    \item \textbf{Parser Monad} - Extremely helpful in modeling parsers. The input is a String to be parsed and the output is a list containing the parsed value of type \textit{a} and the remaining unparsed String. The list represents all the possible parses of the input String; being empty if nothing is parsed, having only one parse if there is one parse and so on. The parser monad is equivalent to the combination between the list monad and the state transformer monad.  
    \begin{center}
        \textbf{type} Parser \textit{a} = String $\rightarrow$ [(\textit{a}, String)] 
    \end{center}
\end{itemize}
Each one of the above mentioned definitions needs to comply with the three monadic laws in order to guarantee that the composition of functions with side effects is \textit{associative} and has an \textit{identity} (Wadler, 1992).

\subsection{Maybe}
The Maybe monad has been selected to provide a concrete insight on how a monad works in practice.   


\end{document}
