\documentclass[a4paper, onecolumn]{article}
    \usepackage[utf8]{inputenc}
    \usepackage{blindtext}
    \usepackage{cite}
    \usepackage{comment}
    \usepackage{color}
    \usepackage{listings}
    \usepackage{tcolorbox}
    \usepackage[a4paper,left=2.9cm,right=2.9cm,top=4cm,bottom=4cm]{geometry}
    
    \title{\Large{Research Seminar Software Science} \\
    \huge{Simulation of monadic effects in Haskell}}
    \author{Brigel Pineti}
    \date{April 2018}
    
    \begin{document}
    
    \maketitle
    
    \section*{Abstract}
    
    TODO: Write once the paper is coming to an end!
    
    \section{Introduction}
    
    Pure function languages like Haskell rule out side effects. Why? Firstly, to allow unrestricted application of program transformation and equation logic. Secondly, being a non-strict language, Haskell's order of side effects is undefined. The aim of this paper is to show how monads can be used to capture impure effects into a pure language. The code snippets attached to this paper are implemented in Haskell. Section 2 will provide an overview on the characteristics of the language being used. Section 3 describes the construction of a monad, the various monadic flavors and the Maybe Monad as an illustrative example to get the reader's feet wet with the complex concept of a Monadic value. In section 4, the construction of a parser with the \textit{Parser} Monad is discussed in detail and the benefits of monadic \textit{alternation} and \textit{sequencing} in parsing are observed. The application of monads is demonstrated in section 5 through a case study to build a parser in practice for a simple programming language. In section 6, the case study is extended with an evaluator for the parsed language using the \textit{State} monad and error handling in included by utilizing the \textit{Exception} Monad. 
    
    \section{Haskell}
    
    In this section are reflected two main features concerning the above mentioned functional language. Taking into consideration that not every reader might be familiar with the properties of the language, I found it necessary to briefly illustrate the laziness and purity of Haskell.  
    
    \subsection{Lazy Evaluation}
    
    Haskell is a functional language with non-strict semantics. What does this mean? An expression is evaluated from the outside in. For instance, the evaluation of \textit{$(a + (b * c))$} will firstly reduce the \textit{$+$} operator and then the inner bracket \textit{$(a * b)$}. \\
    Lazy evaluation is just an implementation approach for a non-strict language. An appropriate definition for laziness can be represented by the term \textit{call-by-need}. Consequently, the evaluation of an expression is delayed until its result is actually needed from another computation. Therefore, the parameters of a function are evaluated only when they are needed and not a moment before.
    
    \subsection{Absence of Side Effects}
    
    A straightforward consequence of laziness is the evaluation order of a Haskell program. Being demand-driven, it becomes impossible for a function call to produce any side effects. Therefore, Haskell is considered to be a \textit{pure language}. For example, a function of type $Char \rightarrow Char$ will neither write nor read any mutable variables. Nevertheless, side effects are without any doubt very convenient. Haskell's restricted side effects resulted in a sluggish input/output. For this reason, monadic I/O was created; thus by leading to a functional language with side effects. 
    \section{Monads}
    Monads originate from a section of mathematics called category theory \cite{categorytheory}. Luckily for the inexperienced readers, it is not required to have prior knowledge in category theory in order to comprehend the application of monads in Haskell. 
    Nevertheless, there exists a certain complexity when it comes to grasping to concept of a monad. From history, monads were initially adopted in Haskell to produce input and output operations. However, the capabilities of monads were not bound to just I/O. Additionally, monads can support multiple operations such as state, non-determinism, continuations, exceptions etc.
    \subsection{Construction}
    For now think of a monad as a way of chaining operations together. 
    In order to have a monad, three components are essential to its construction: 
    \begin{itemize}
        \item a type constructor
        \item a function return
        \item a bind operator ($\gg$=)
    \end{itemize}
    The \textit{return} function and the bind operator ($\gg$=) have the following types: 
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
       return :: a -> M a 
       (>>=)  :: M a -> (a -> M b) -> M b 
      \end{lstlisting}
    \end{tcolorbox}
    In order for the above function definitions to hold, the monad laws need to be satisfied. There exist three monadic laws as presented below: 
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
    right unit             m >>= return  =  m 
    left  unit      return x >>= f       =  f x   
    associative    (m >>= f) >>= g       =  m >>= (\x -> f x >>= g) 
      \end{lstlisting}
    \end{tcolorbox}
    
    According to the laws of right and left unit, the return serves as a collector of a value where no computation occurs. As the type of \textit{return} suggests, it takes a value of type \textit{a}, puts it in a special context \textit{m} and returns as a result \textit{m a}. Furthermore, the associative law guarantees that the bind operator ($\gg$=) is concerned only with the order of computation and not on the manner the operators are nested together. The bind operation can be compared to a semicolon(;) by taking the output from the former step and feeding it to the next step.
    \subsection{Flavors}
    
    It is crucial to understand that there exist more than one kind of monad. As a result, the implementation of the bind function ($\gg$=) mentioned on the previous section differs on various monads. 
    
    \begin{itemize}
        \item \textbf{Fail Monad} - Consider the case that each step will \textit{return} either a success or a fail. The bind operator can be constructed in such a way that the next step will be executed only if the former step succeeds. Hence, there is no need to check if the previous step failed since the \textit{fail monad} will take care of this by automatically aborting in case of a former failing step.
        \begin{center}
            \textbf{data} Failure \textit{a} = Fail $\vert$ Success \textit{a} 
        \end{center}
        \item \textbf{Exception Monad} - An efficient way of handling errors by either raising an exception or returning the corresponding value. 
        \begin{center}
            \textbf{data} Exc \textit{e a} = Exception \textit{e} $\vert$ OK \textit{a}
        \end{center}
        \item \textbf{List Monad} - Models non-deterministic computation and return a sequence of values. There exists the opportunity to program each step to return multiple values. The bind operator ($\gg$=) may be used to iterate over these values and pass each value to the upcoming step. Otherwise various loops would be needed to deal with all these results. As it can be seen, the bind operator of the list monad would be very beneficial by removing the complexity of adding loops to retrieve information. 
        \begin{center}
            \textbf{type} List \textit{a} = [\textit{a}]
        \end{center}
        \item \textbf{State Reader Monad} - Accepts a state as an input and reads a value of type \textit{a} without performing any computation on the state itself. The bind operator can be used to pass additional data with the sole purpose to access it from anywhere without the necessity to manually pass data to every step in order to read it. 
        \begin{center}
            \textbf{type} SR \textit{s a} = \textit{s} $\rightarrow$ \textit{a}
        \end{center}
        \item \textbf{State Transformer Monad} - Mainly used to thread the state during program execution. The transformer takes the old state as an input and returns a tuple of the value of type \textit{a} and the new state. Additionally, the state transformer is perfect for simulating update operations.
        \begin{center}
            \textbf{type} ST \textit{s a} = \textit{s} $\rightarrow$ (\textit{a}, \textit{s})
        \end{center}
        \item \textbf{Parser Monad} - Extremely helpful in modeling parsers. The input is a String to be parsed and the output is a list containing the parsed value of type \textit{a} and the remaining unparsed String. The list represents all the possible parses of the input String; being empty if nothing is parsed, having only one parse if there is one parse and so on. The parser monad is equivalent to the combination between the list monad and the state transformer monad.  
        \begin{center}
            \textbf{type} Parser \textit{a} = String $\rightarrow$ [(\textit{a}, String)] 
        \end{center}
    \end{itemize}
    It is thought-provoking how any type can act as a \textit{Monad} just by defining some functions that comply with the three monadic laws in order to guarantee that the composition of functions with side effects is \textit{associative} and has an \textit{identity} \cite{essenceFP}.
    
    \subsection{Maybe}
    The Maybe monad has been selected to provide a concrete insight on how a monad works in practice. The nature of Maybe provides a smooth solution to situations where some function may or may not return a value. The type constructor is presented below:
    
    \begin{center}
        \textbf{data} Maybe \textit{a} = Just \textit{a} $\vert$ Nothing 
    \end{center}
    The Maybe type constructor suggests that for any value of type \textit{a}, it returns either \textit{Just} that value or \textit{Nothing}. The \textit{return} and ($\gg$=) are defined like this:
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
        return :: a -> Maybe a
        return x     = Just x 
    \end{lstlisting}
    \end{tcolorbox}
    The \textbf{return} will take as an input a normal value and place it inside the context of a Maybe value. In this case, it is placed inside the \textbf{Just} value constructor. For example: 
    
    \begin{center}
        ghci$>$ \textbf{return} \textit{``hello"}
    \end{center}
    The resulting value of the above operation will be \textbf{Just} \textit{``hello"}.
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
        (>>=) :: Maybe a -> (\a -> Maybe b) -> Maybe b
        Nothing >>= f = Nothing
        Just x  >>= f = f x
    \end{lstlisting}
    \end{tcolorbox}
    The binding operator ($\gg$=) takes \textbf{Maybe a} and a function of type \textbf{a $\rightarrow$ Maybe b} and somehow applies the function to \textbf{Maybe a} in order to return \textbf{Maybe b}. An example might be useful to illustrate this: 
    \begin{center}
    ghci$>$ \textbf{Just} \textit{``smile"} $\gg=$ \textbackslash x $\rightarrow$ \textbf{Just} (\textit{x} ++ \textit{`` :)"})
    \end{center}
    When the function is applied to \textbf{Just ``smile"}, it removes \textbf{``smile"} from its special context and passes it as an input to the function \textbf{\textbackslash x $\rightarrow$ Just (x ++ `` :)")}.  The function will return \textbf{Just ``smile :)"}. This is what I call magic! On the other hand, replacing \textbf{Just ``smile"} with the value constructor \textbf{Nothing} will always result in \textbf{Nothing} being independent from the function \textbf{f}.
    
    
    \subsection{Conclusions}
    A monad is helpful in chaining various computations together and managing how that chain of action functions as a unit. In addition, the monadic laws will be in charge of supervising two imperative cases:
    
    \begin{itemize}
        \item state between actions by guaranteeing that they are executed in the appropriate order 
        \item failing situations by ensuring that upcoming actions are aborted and the whole expression is evaluated to a failure
    \end{itemize}
    Therefore, it is essential to understand how the Maybe types work as a Monad in order to then comprehend more complicated Monads like \textit{State} and \textit{IO}.
    
    \section{Parsers}
    Monads are valuable in modeling sequencing and alternation in recursive decent parsers. The methods described in this section are extensible since parsers are treated as first-class values and combinators are defined in Haskell. Additionally, it portrays the purity of functional programming.
    
    \subsection{State Transformers}
    
    Parsers in functional programming are pictured as state transformers \cite{original}. Recall state transformers monads from section 3.2.  
    
    \begin{tcolorbox}
      \begin{lstlisting}[language=Haskell]
      type Parse p = State -> [(p, State)]
      type State    = String  
      
      \end{lstlisting}
    \end{tcolorbox}
    
    The parser of type \textit{p} takes a state represented as a string ready to be parsed and returns a list containing the value of type \textit{p} parsed from the string and a state represented again as a string that is yet to be parsed. Since a parser may not consume all of its input string, the unconsumed suffix of the input must be returned along with the prefix of the input. As a result, the outcome of a parser must be a list enclosing consumed and unconsumed part of the input string. Additionally, the case when an empty list is returned is treated as a failure \cite{pearls}. On the other hand, an non-empty list is marked as a success.
    
    \subsection{Primitive Parsers}
    
    This subsection will introduce three primitive parsers with the sole purpose to achieve diverse parser combinators. \\ \\
    Firstly, the parser oneItem will fail if the input provided is an empty list. Otherwise, it will eat only the first character of the input string and leave the other part of the input unconsumed. This parser is defined by applying pattern matching on the list. 
     
    
    \begin{lstlisting}[language=Haskell]
      oneItem         :: Parse Char
      oneItem []       = []
      oneItem (l : ls) = [(l, ls)]
    \end{lstlisting}
    
    To better illustrate follow the examples below that treat both cases.
    
    \begin{lstlisting}[language=Haskell]
      oneItem ""       = []
      oneItem "parser" = [('p', "arser")]
    \end{lstlisting}
    Secondly, the parser \textbf{zero} will always fail, regardless of the input string provided. 
    
    \begin{lstlisting}[language=Haskell]
      zero :: Parse p
      zero = \input -> [] 
    \end{lstlisting}
    
    In other words, the outcome of the \textbf{zero} parser will always be an empty list. \\ \\
    Finally, the \textbf{result v} parser will always succeed by returning the value \textit{v} without consuming any input.
    
    \begin{lstlisting}[language=Haskell]
      result :: p -> Parse p
      result v input = [(v, input)]
    \end{lstlisting}
    
    \subsection{Parser Combinators}
    
    The three primitive parsers that were defined in the previous subsection aren't very helpful when used separately. Hence, these parsers have to be combined together through some operators in order to actually produce something useful. In this subsection, two operators are introduced: \textit{sequence} and \textit{alternation}. 
    
    \subsubsection{Sequencing}
    
    Sequencing of parsers is usually captured by a combinator called \textit{seq} where two parsers are applied one after another with the result from the two parsers being combined together as a tuple. The example below will illustrate the definition of the \textit{seq} operator:
    
    \begin{tcolorbox}
    
    \begin{lstlisting}[language=Haskell]
      seq :: Parse a -> Parse b -> Parser (a, b)
      p `seq` q = \input -> [((v, u), input'') | (v, input') <- p input,
                                                (u, input'') <- q input']
    \end{lstlisting}
    \end{tcolorbox}
    
    In order to define the \textit{seq} operator, list comprehensions come in handy. Initially, the right side of the vertical bar is executed. In case, the parser \textbf{p} takes a non-empty \textbf{input} string, then a list of pairs will be returned accommodating the consumed prefix of the \textbf{input} and the unconsumed suffix of the \textbf{input}. The resulting list of pairs for the parser \textbf{p input} is \textbf{(v, input')}. \\ \\ Immediately after the parser \textbf{p} has accomplished it's goal, the parser \textbf{q} will take as an input string the un-parsed string from the former parser. In other words, the parser \textbf{q} takes as an input string the string \textbf{input'}. The outcome of the parser \textbf{q input'} will be the list of pairs \textbf{(w, input'')} where \textbf{u} is the \textit{prefix of the input'} and \textbf{input''} is the \textit{suffix of the input'}. \\ \\
    As a last step (the left side of the vertical bar), the parser combinator \textbf{seq} will sew together the values \textbf{u} and \textbf{v} into a tuple and return a list of pairs like \textbf{[((v, u), input'')]}. \\ \\
    In the above situation, the operator \textbf{seq} will continuously nest tuples together thus be increasing complexity and making it painful to handle. \\ \\
    The headache introduced by the nested tuples can be smoothly averted by adopting monadic sequencing. In order to achieve this type of sequencing the bind operator has been defined. The type of this operator resembles with the type of the bind operator from monad instance \textit{m}. Recalling from the section 3.1 of Monad Construction, the type of ($>>$=) was {\textbf{m a $\rightarrow$ (a $\rightarrow$ m b) $\rightarrow$ m b}}. In the monadic sequencing case, the \textit{m} is being replaced with \textit{Parse}.
    
    \begin{tcolorbox}
    
    \begin{lstlisting}[language=Haskell]
      bind :: Parse a -> (a -> Parse b) -> Parser b
      p `bind` f = \input -> concat [f v input' | (v, input') <- p input]
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{bind} combinator is an infix operator that take a parser from the left side and a function that itself takes a normal value and returns another parser from the right side. The infix \textbf{bind} is defined as a lambda expression taking a string as an input and producing a concatenation of the values parsed by the sequencing of parsers. \\ \\
    At first, the parser \textbf{p} is applied to the input string and results in a list of pairs \textbf{(v, input')} where \textit{v} is the first item exhausted by the parser \textbf{p} and the \textit{input'} is the remaining input string. \\ \\
    Now, the function \textbf{f} applies to the normal value \textbf{v} to form a parser \textbf{f v} which is afterwards applied the string \textbf{input'}. The resulting parser will be a list of concatenated lists. The examples below will help in clarifying any confusion being raised by the \textbf{bind} operator. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseOneItem :: Parse Char
      parseOneItem  = oneItem `bind` \x -> result x 
    \end{lstlisting}
    \end{tcolorbox}
    
    The parser \textbf{parseOneItem} produces that same result as the primitive parser \textbf{oneItem} defined in section 5.2 but their implementation differs. The latter parser is using the former parser in its definition. \\ \\ 
    In practice, the \textbf{oneItem} parser is consuming the first character of an input string and through the \textbf{bind} operator this value is being passed as an input to the lambda function expression \textbf{\textbackslash x $\rightarrow$ result x}. Furthermore, this function is returning the primitive \textbf{result} parser. From section 5.2, the \textbf{result} parser will always succeed by returning the value x that was passed to it without exhausting any input string. In this case, the goal of the \textbf{result} parser is to just display what was parsed and what was not parsed, and doesn't need to worry about parsing since the \textbf{oneItem} parser is taking care of that.  
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseTwoItems :: Parse (Char, Char)
      parseTwoItems  = oneItem `bind` \x -> oneitem 
                               `bind` \y -> result (x, y)
    \end{lstlisting}
    \end{tcolorbox}
    
    The parse \textbf{parseTwoItems} manages to parse the first two characters of the input string and returns the two parsed characters and remaining part of the input string which is not yet parsed. \\ \\
    In practice, the \textbf{parseTwoItems} is using two \textit{bind} infix operators. In the first \textit{bind}, the \textbf{oneItem} parser is eating the first character of the input string and passing the corresponding value to the function \textbf{\textbackslash x $\rightarrow$ oneItem}, which differently from the previous \textbf{parseOneItem} parser is returning another \textbf{oneItem} parser instead of the primitive \textbf{result} parser. In the second \textit{bind}, the  other \textbf{oneItem} parser is devouring the first character of the unparsed input string and passing that value as an input to the function \textbf{\textbackslash y $\rightarrow$ result(x, y)}. Finally, the resulting output will be handled by the \textbf{result} parser which will return the values of \textit{x} and \textit{y} being correspondingly the first and the second character of initial input string, together with the unparsed input string as a tuple. \\ \\ 
    The following example will better illustrate the outcome when parsing a string:
       \begin{center}
            \textbf{ghci$>$} parseTwoItems \textcolor{red}{``rera"} \\
            $\big[$((\textcolor{green}{`r'}, \textcolor{green}{`e'}), \textcolor{red}{``ra"})$\big]$
        \end{center}
        
    From the above example, it can be deduced that the outcome of the first parser can be sequentially consumed by the second parser and so on if other parsers are included. Hence, the \textit{bind} infix operator will dodge the complication introduced by the nested tuples. Consequently, the \textit{seq} can be defined using the \textit{bind} operator: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      p `seq` q = p `bind` \x -> q `bind` \y -> result (x, y)
    \end{lstlisting}
    \end{tcolorbox}
    
    The monadic \textit{bind} operator can be used to define parsers of a different nature. For example, a \textbf{satisfy} combinator may be constructed as a function that takes a predicate as input and returns a parser that consumes the first element of a string if the predicate is true and fails if the predicate is false. In order to fulfill the required parsing behavior, the primitive parsers \textit{oneItem}, \textit{result} and \textit{zero} mentioned in section 5.2 are necessary. Let's observe how the \textbf{satisfy} can be implemented: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      satisfy :: (Char -> Bool) -> Parse Char
      satisfy pred = oneItem `bind` \x -> if pred x 
                                          then result x 
                                          else zero
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{satisfy} combinator will initially parse the first item of the input provided. Afterwards, through the \textit{bind} operator this value is passed as an input to the function taking the first character as an input and returning an if statement as an output. The if statement checks what the predicate returns. If the predicate is true the first value parsed and the unparsed input string are returned through the \textbf{result} parser, otherwise the parser will fail and will return an empty list through the \textbf{zero} parser.  \\ \\
    A benefit of using the monadic approach to define parsers is the support provided by the \textit{monad comprehension syntax} \cite{bringMonadComprehension}. Monad comprehensions will promote readability of parsers. Hence, the satisfy can be transformed into the following structure: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      satisfy pred = [x | x <- oneItem, pred x]
    \end{lstlisting}
    \end{tcolorbox}
    
    The \textbf{satisfy} parser combinator can be easily extended to add precision in parsers. Hence, parsers like \textbf{singleChar}, \textbf{isdigit}. \textbf{islowercase} and \textbf{isuppercase} can be defined:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      singleChar   :: Char -> Parse Char
      singleChar a  = satisfy (\b -> a == b)
      
      isdigit :: Parse Char
      isdigit  = satisfy (\a -> a >= '0' && a <= '9')
      
      islowercase :: Parse Char
      islowercase  = satisfy (\a -> a >= 'a' && a <= 'z')
      
      isuppercase :: Parse Char 
      isuppercase  = satisfy (\a -> a >= 'A' && a <= 'Z')
    \end{lstlisting}
    \end{tcolorbox}
    
    The names for each parser are speaking for themselves. Each of the above parsers will success in parsing the first character if the predicate takes an input for the satisfy combinator is true. On the other hand, the parser will fail and return [ ]. 
    
    In conclusion, it is very important to comprehend that the monadic \textbf{bind} made possible the creation of \textbf{satisfy} and what followed as an extension of \textbf{satisfy}. However, this is not the end of the commodity that the \textbf{bind} operator provides. For instance, a new parser may be created to parse two digits or more if the predicate holds or to fail if it doesn't. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      parseTwoDigits :: Parse (Char, Char)
      parseTwoDigits  = isdigit `bind` \x -> isdigit 
                                `bind` \y -> result(x,y)
    \end{lstlisting}
    \end{tcolorbox}
    
    Applying this parser to an input string ``12rera" will succeed with the result [((`1', `2'), ``rera")] whereas in case of an input ``1rera" will fail and return [ ] since the second parsed character \textit{`r'} is not a digit. \\ \\
    Nevertheless, it would not be convenient to create new parsers each time more items need to be parsed. For that reason, \textit{recursive parsers} are desired. Additionally, recursive operation must be terminated at some point. In order to achieve or not termination, the \textbf{alternation} combinator has to be used but more on that on the next subsection.
    \subsubsection{Alternation}
    
    In this subsection, the attention will be redirected towards producing alternation in parsers.  The implementation of 2 parsers being alternated together will be represented by the operator (\texttt{+++}) and we will refer to this as the \textbf{plus} parser. Have a look at the following Haskell snippet to understand how alternation is attained:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell]
      (+++) :: Parse a -> Parse a -> Parse a
      p +++ q  = \input -> (p input ++ q input)
    \end{lstlisting}
    \end{tcolorbox}
    \noindent The nature of the plus parser can be illustrated by defining the \textbf{isletter} parser which alternates two of the already defined parsers from the previous subsection: \textbf{islowercase} and \textbf{isuppercase}.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        isletter :: Parse Char
        isletter  = islowercase +++ isuppercase
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textbf{isletter} parser will parse the first character of input string if it is a lowercase or an uppercase letter. How does it accomplish this? Firstly, it will apply parser \textbf{islowercase} to the input string and yield a tuple with resulting parsed character together with remaining not parsed input string. Secondly, it will apply the parser \textbf{isuppercase} to the same input string and return a tuple containing the resulting  parsed character together with the yet to be parsed input string. Finally, it will concatenate the resulting tuples from \textbf{islowercase} and \textbf{isuppercase} parsers into one list. As shown from the example below, the \textbf{isletter} parser is exhibiting the correct behavior by just returning the parsed character is it is a letter.
    
    \begin{center}
            \textbf{ghci$>$} isletter \textcolor{red}{``rera"} \\
            $\big[$(\textcolor{green}{`r'}, \textcolor{red}{``era"})$\big]$
    \end{center}
    
    \noindent Actually, the resulting outcome is the output produced by the \textbf{islowercase} parser while the \textbf{isuppercase} parser returns an empty list. If the \textbf{isuppercase} parser returned a non empty list , the resulting output would be appended to the output of the \textbf{islowercase} parser, thus by producing some ambiguous behavior. In other words, there is an issue with the non-deterministic behavior of the \textbf{plus} parser. \\ \\
    The nature of this complication can be clearly represented by the \textbf{islower\_r} parser which alternates two of the already defined parsers from the previous subsection: \textbf{islowercase} and \textbf{singleChar}. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        islower_r :: Parse Char
        islower_r  = islowercase +++ singleChar `r'
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The role that the \textbf{islower\_r} exhibits is not very useful in parsing terms but in this case it is essential in exposing the hidden inadequate behavior of the \textbf{plus} parser. Now, let's apply the \textbf{islower\_r} parser to an input string that contains `r' as it's first character to observe what happens.
    
    \begin{center}
            \textbf{ghci$>$} islower\_r \textcolor{red}{``rera"} \\
            $\big[$(\textcolor{green}{`r'}, \textcolor{red}{``era"}), (\textcolor{green}{`r'}, \textcolor{red}{``era"})$\big]$
        \end{center}
    
     \noindent The \textbf{islower\_r} parser is producing duplicates inside the list while just one of the duplicates is necessary to be displayed. At the moment, even though the first parser will succeed in parsing the input, the second parser will always be applied to the same input.This is not the desired behaviour from alternation of parsers. The undesired behaviour is intensified by the \textbf{isword} parser which is defined below:
     
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        isword :: Parse String
        isword = word +++ result ""
                   where word = isletter `bind` \x -> isword 
                                         `bind` \xs -> result (x:xs)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent For example let's apply the \textbf{isword} parser to an input string.
    
    \begin{center}
            \textbf{ghci$>$} isword \textcolor{red}{``rera"} \\
               $\big[$(\textcolor{green}{`rera'}, \textcolor{red}{``"}), (\textcolor{green}{`rer'}, \textcolor{red}{``a"})
            (\textcolor{green}{`re'}, \textcolor{red}{``ra"})
            (\textcolor{green}{`r'}, \textcolor{red}{``era"})
            (\textcolor{green}{`'}, \textcolor{red}{``rera"})$\big]$
        \end{center}
        
    \noindent As it can be seen the behavior that the \textbf{isword} parser demonstrates is not as expected. The \textbf{isword} parser is supposed to parse an entire string, thus the only relevant output to be awaited from \textbf{isword ``rera"} is \textbf{[(``rera", ``")]}. \\ \\
      In order to achieve the expected behaviour some changes have to be made to the \textbf{plus} parser. The end goal is to allow the consequent parser to parse the input string only if the initial parser has failed in doing so. Additionally, if the initial parser succeeds in parsing the input, the program is terminated and the parsed result is returned. How can the \textbf{plus} parser be altered so that it can introduce this deterministic behavior? \\ \\ 
      One way to transform the \textbf{plus} parser is by applying the \textit{case of} notation on the output that the first parser \textit{p} produces when applied to the input string. In case, the parser \textit{p} when eating the input string returns a parsed value together with the yet to be parser string then the \textbf{plus} parser terminates and returns the mentioned result. However, if the parser \textit{p} return an empty list after parsing the input string then and only then the second parser \textit{q} will be applied to same input string as parser \textit{p}. The implementation of the transformed \textbf{plus} parser is presented below:
     
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        p +++ q = \input -> case p input of
                              [(val, input')] -> [(val, input')]
                                           [] -> q input
    \end{lstlisting}
    \end{tcolorbox}
     
     \noindent With this modification, some deterministic behaviour has been inserted in the \textbf{plus} parser thus by fixing the sketchy behavior that was being manifested before. \\ \\
     Another way to customize the \textbf{plus} parser is by utilizing the Maybe monad. The following snippet of Haskell code shows how the Just and Nothing constructors can be integrated in the \textbf{plus} parser:
     
     \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        p +++ q = \input -> case p input of
                              Just (val, input') -> Just (val, input')
                                         Nothing -> q input
    \end{lstlisting}
    \end{tcolorbox}
    
    Therefore, both the \textit{List} and the \textit{Maybe} monad in combination with \textit{case of} notation helped in upgrading the behavior of the \textbf{plus} parser. 
    
    \section{A Case Study}
    
    In order to properly illustrate the monadic techniques described on section 5, a case study will be conducted on creating a parser in a monadic way for a simple programming language with the following constructs: 
    
    \begin{itemize}
        \item Only \textit{Integer} and \textit{String} variable declarations \\
        \textbf{Integer} a = 42 or \textbf{String} b = `Hello Monads!'
        \item Output functions \\ 
        \textbf{print}(a)
        \item Input functions \\
        \textbf{get}(a)
        \item Variables assignments and operators \\ 
        a \textbf{:=} b where a and b are variables \\ 
        a \textbf{:=} b op c where a, b, and c are variables and op is an \textit{arithmetic operator} (*, /, +, -) or a \textit{comparison operator} (==, !=, $<$=, $<$, $>$=, $>$) 
        \item While loop \\ 
        \textbf{while}(\textit{condition}) \textbf{do} \textit{statements} \textbf{od}
    \end{itemize}
    
    \noindent Additionally, on section 7 the created parser will be evaluated with the usage of the \textbf{State} and \textbf{Exception} monads. 
    
    \subsection{Algebraic Data Types}
    
    In order to parse any of the statements of this simple programming language, an algebraic data type type namely \textbf{AST} needs to be created. This \textbf{AST} will provide a tree representation of the abstract structure of the programming language. The \textit{Abstract Syntax Tree} is portrayed through Haskell's algebraic data types and its implementation is illustrated below:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
        data AST = DeclarationInt String Int 
                 | DeclarationString String String
                 | Print String
                 | Get String
                 | AssignmentVar String String
                 | AssignmentOp String String Operator String 
                 | WhileLoop Condition [AST] deriving (Show)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent As it can be seen, the AST is referencing two data types which have not been created yet. As a consequence, the definition of the \textbf{Operator} and \textbf{Condition} data types has been defined below: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    data Operator  = Multi | Div | Plus | Minus
                   | Equal | NotEqual
                   | GreaterThan | GreaterThanOrEqual 
                   | LessThan | LessThanOrEqual deriving (Show)
        
    data Condition = Condition String Operator String deriving (Show) 
    \end{lstlisting}
    \end{tcolorbox}
    
    \subsection{Tokenizer}
    
    An important step in order to parse the statements of our programming language is slicing input strings into fragments such as keywords, symbols and other elements called tokens. Therefore, a \textbf{tokenizer} has been built to mimic this behavior.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    tokenize         :: String -> Parse String
    tokenize []       = result []
    tokenize (x : xs) = singleChar x `bind` \first -> tokenize xs 
                              `bind` \rest  -> result (first:rest)
     \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textit{tokenizer} is eating a keyword and an input string to then return a tuple of parsed and unparsed input string. Whether the content of the input string is going to be parsed will depend on the value of the keyword which itself is also a string. Obviously, if this keyword is an empty string than nothing will be parsed no matter the content of the input string. In case, the token in a non empty string then the \textit{tokenizer} will use the \textit{singleChar} parser to parse the first character of the input string and through the bind operator pass the parsed character as an input to the lambda expression \textbf{\textbackslash first -$>$ tokenize xs}. Then, the function will recursively apply the \textit{tokenizer} to the rest of the keyword. This operation will finish when the whole keyword has been traversed. Through another bind operator, the resulting value of \textbf{tokenize xs} will be passed as an input to the lambda expression taking the \textbf{rest} variable and returning a \textit{result} parser. The \textit{result} parser takes as an input a list containing the parsed and unparsed input string which is also the output of the \textit{tokenizer}. \\ \\
    The following example will illustrate how the \textit{tokenizer} will parse the Integer keyword:
    
    \begin{center}
            \textbf{ghci$>$} tokenize \textcolor{red}{``Integer"} ``Integer a = 5" \\
             $\big[$(\textcolor{green}{``Integer"}, \textcolor{red}{`` a = 5"})$\big]$
        \end{center}
    
    \noindent Therefore, the \textit{tokenizer} will come in handy in parsing any keyword the programmer wants. In the upcoming sections, we will see how the tokenize can be used as an asset to build the parsers of each statement. 
    
    \subsection{Statements}
    
    In this section, the approaches used to parse the statements of our programming language will be illustrated. Thanks to the \textit{result} parser and the \textit{bind} operator, this process has been simplified to a great extent and parsers are much more readable. 
    
    \subsubsection{Variable Declaration}
    
    The simple programming language used for this case study contains only two types of variables: \textbf{Strings} and \textbf{Integers}. The declaration of a variable contains the following format: a keyword (either \textit{String} or \textit{Integer}), a space, a variable name (list of characters), a space, an equality operator, a space, a number for integer declaration or a string surrounded in single quotes for string declaration. \\ \\
    Keeping in mind the format, the construction of the \textbf{parse\textunderscore declaration\textunderscore string} and \\ \textbf{parse\textunderscore declaration\textunderscore int} is rather straightforward since all the parsers needed to construct these parsers have already been defined on section 5.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_declaration_string :: Parse AST
    parse_declaration_string = 
        tokenize "String " `bind` \string -> isword 
                           `bind` \id -> tokenize " = "          
                           `bind` \eq -> singleChar '\''  
                           `bind` \startQuote -> isword 
                           `bind` \word -> singleChar '\''    
                           `bind` \endQuoute -> 
        result (DeclarationString id (startQuote : word ++ [endQuoute])) 
     \end{lstlisting}
    \end{tcolorbox}
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
     parse_declaration_int :: Parse AST 
     parse_declaration_int = 
        tokenize "Integer " `bind` \integer -> isword 
                            `bind` \id -> tokenize " = " 
                            `bind` \eq -> is_number 
                            `bind` \num ->
        result (DeclarationInt id (read num :: Int) ) 
     \end{lstlisting}
    \end{tcolorbox}
    
    \noindent From the above implementations, it can be seen how important the \textit{tokenizer} is by parsing groups of characters like ``\textbf{String }",``\textbf{Integer }", and ``\textbf{ = }". Additionally, binding operators combine parsers and provide a smooth transition between each one of them. The \textbf{result} parser is utilized to yield a list of tuples containing the corresponding parsed AST and unparsed input string.  
    
    
    \subsubsection{Input and Output}
    
    The behavior of input and output operations is represented with the keywords \textbf{get} and \textbf{print} respectively. The format in parsing input and output is the following: a keyword (either \textbf{get} or \textbf{print}), an opening bracket, variable name, and a closing bracket. The implementation of the parsers that will parse the input and output statements is presented below:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_get :: Parse AST
    parse_get  = tokenize "get(" `bind` \get -> isword 
                                 `bind` \var -> singleChar ')' 
                                 `bind` \close -> result (Get var) 
     \end{lstlisting}
    \end{tcolorbox}
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_print :: Parse AST
    parse_print  = tokenize "print(" `bind` \print -> isword 
                                     `bind` \var -> singleChar ')' 
                                     `bind` \close -> result (Print var) 
     \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The construction of these parsers is much simpler that the parsers from variable declaration since there is not so much tokens to parse in this situation. The \textit{tokenizer} is again used to parse the keywords together with opening bracket: \textbf{"print("} and \textbf{get(}. The outcome in both parsers contains the \textbf{result} parser taking as input the AST values \textbf{Get var} or \textbf{Print var} (where \textit{var} is the string parsed by the \textit{isword} parser) and the remaining unparsed input string.
    
    
    \subsubsection{Variable Assignment}
    
    Variable assignment will take place in two forms where the right side of the assignment can be either just a variable or a combination of two variables with a comparison or an arithmetic operator in between. The assignment format is: a variable name, a space, a colon, an equality operator, a space and the right side (a variable name or a variable name, a space, an operator, a space, another variable name). The implementation of the first case of variable assignment is presented below:  
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_assignment_var :: Parse AST
    parse_assignment_var = 
        isword `bind` \leftvar -> tokenize " := " 
               `bind` \eq -> isword 
               `bind` \rightvar -> 
        result (AssignmentVar leftvar rightvar) 
     
     \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The second case of variable assignment is not as simple as the first one since some additional parsers need to be included in order to parse operators (\textit{comparison} and \textit{arithmetic}). Each operator is represented with a different parser that has type \textbf{Parse Operator} since an \textit{Operator} data type is being parsed and not an \textit{AST} data type. Initially, the parsers for the arithmetic operators are illustrated: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_multi_op :: Parse Operator
    is_multi_op = singleChar '*' `bind` \multi -> result Multi
    
    is_div_op :: Parse Operator
    is_div_op = singleChar '/' `bind` \div -> result Div
    
    is_plus_op :: Parse Operator
    is_plus_op  = singleChar '+' `bind` \plus -> result Plus
    
    is_minus_op :: Parse Operator
    is_minus_op  = singleChar '-' `bind` \minus -> result Minus
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent As it can be seen, the design is rather simple containing a single \textbf{bind} between the \textbf{singleChar} parser and a function taking the operator character parsed and returning the \textbf{result} parser. The \textbf{result} parser is used to represent the outcome of these parsers taking one of the value constructors of \textit{Operator} (depending on the operator parsed) and the remaining input string. \\ \\ 
    Next, the parsers for the \textit{comparison} operators are illustrated:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_greaterthan_op :: Parse Operator 
    is_greaterthan_op = singleChar '>' `bind` \greater -> 
                                        result GreaterThan
    
    is_greaterthan_eq_op :: Parse Operator 
    is_greaterthan_eq_op = tokenize ">=" `bind` \eq -> 
                                         result GreaterThanOrEqual
    
    is_lessthan_op :: Parse Operator 
    is_lessthan_op = singleChar '<' `bind` \less ->
                                      result LessThan
    
    is_lessthan_eq_op :: Parse Operator 
    is_lessthan_eq_op = tokenize "<=" `bind` \eq -> 
                                      result LessThanOrEqual
    
    is_eq_op :: Parse Operator
    is_eq_op = tokenize "==" `bind` \eq2 -> result Equal
    
    is_not_eq_op :: Parse Operator
    is_not_eq_op = tokenize "!=" `bind` \eq -> result NotEqual
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent As expected, the construction is equivalent to the \textit{arithmetic} parsers. Although, on the operators (==, !=, $<$=, $>$=) a \textit{tokenizer} is used since more than one character needs to be recognized to then be parsed. \\ \\
    At the moment, all the parsers to recognize \textit{arithmetic} and \textit{comparison} operators have been defined. The next step would be creating another parser that encapsulates all of the above parsers to recognize operators in general. How can this be achieved? Well, with the elegance of \textit{alternation} of course! However, before creating the final \textbf{is\textunderscore operator} parser, two parsers need to be defined in order to wrap \textit{arithmetic} and \textit{comparison} operators. Let's see how nice and neat these parsers looks like:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_arith_op :: Parse Operator 
    is_arith_op = is_multi_op +++ is_div_op 
                  +++ is_plus_op +++ is_minus_op
                  
    is_comp_op :: Parse Operator
    is_comp_op = is_greaterthan_eq_op +++ is_greaterthan_op 
                 +++ is_lessthan_eq_op +++ is_lessthan_op 
                 +++ is_eq_op +++ is_not_eq_op
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent In the \textbf{is\textunderscore comp\textunderscore op} parser the order of the ($<$=, $<$) and ($>=$, $>$) parsers is very important since the monadic \textit{alternation} operator will compute the next parser only if the previous parser fails. Lets suppose that the \textbf{is\textunderscore greaterthan\textunderscore op} parser precedes the \textbf{is\textunderscore greaterthan\textunderscore eq\textunderscore op} parser in the alternation chain. As a consequence, the ($>$=) operator will never be parsed. Why? If the \textbf{is\textunderscore comp\textunderscore op} tries to parse the input string $>$=, then the \textbf{is\textunderscore greaterthan\textunderscore eq\textunderscore op} will be computed by succeeding in parsing just $>$ and ignoring any parser that follows.
    
    \begin{center}
            \textbf{ghci$>$} is\textunderscore comp\textunderscore op \textcolor{red}{``$>$="} \\
             $\big[$(\textcolor{green}{``GreaterThan"}, \textcolor{red}{``="})$\big]$
        \end{center}
    
    \noindent The same situation applies to the ($<$=, $<$) combination. Therefore, order is important between these operators. \\ \\ 
    After clearing this ambiguity, it is safe to create the final \textbf{is\textunderscore operator} parser which will alternate between the \textit{arithmetic} and \textit{comparison} operator parsers where order will not matter. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_operator :: Parse Operator 
    is_operator = is_arith_op +++ is_comp_op
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The creation of the \textbf{is\textunderscore operator} parser makes it viable to finally build the variable assignment parser where the right side contains an operator between two variable names. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_assignment_op :: Parse AST
    parse_assignment_op  = isword `bind` \leftvar -> tokenize " := " 
                                  `bind` \eq -> isword 
                                  `bind` \leftopvar -> singleChar ' ' 
                                  `bind` \space2 -> is_operator 
                                  `bind` \operator -> singleChar ' ' 
                                  `bind` \space3 -> isword 
                                  `bind` \rightopvar -> 
        result (AssignmentOp leftvar leftopvar operator rightopvar)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent Several \textbf{bind} operators have been used to construct this parser showing how the concept of monadic \textit{sequencing} keeps the steps transparent and provides a smooth transition between the different parsers used. 
    
    \subsubsection{While Loop}
    
    The loop in our programming language will be recognized by the \textbf{while} keyword. The loop block has the following format: the \textbf{while} keyword, opening bracket, condition, closing bracket, a space, the \textbf{do} keyword, a space, any of the above statements, a space, and the \textbf{od} keyword. In order to build a parser for a while statement, two additional parsers are required. Firstly, a parser for the condition part having the format: a variable name, a space, a comparison operator, a space and a another variable name. Secondly, a parser which accumulates all the statement parsers that have been defined above. For now, it will be assumed that this parser has already been implemented. The actual implementation is discussed on the section 6.5. \\ \\
    \noindent Let's start with the construction of the \textit{condition} parser. It's implementation is presented below and it will use the \textbf{is\textunderscore comp\textunderscore op} parser to parse only \textit{comparison} operators: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    is_loop_condition :: Parse Condition
    is_loop_condition = isword `bind` \leftside -> singleChar ' ' 
                               `bind` \space1 -> is_comp_op 
                               `bind` \operator -> singleChar ' ' 
                               `bind` \space2 -> isword 
                               `bind` \rightside -> 
                        result (Condition leftside operator rightside)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent As it was previously stated, the \textbf{my\textunderscore parser} will encapsulate the behavior of all the statement parsers that have been defined. Having defined the parsers \textbf{is\textunderscore loop\textunderscore condition} and \textbf{my\textunderscore parser} will give the green light to accomplishing the task of parsing the while loop.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_while_loop :: Parse AST
    parse_while_loop = 
                  tokenize "while(" `bind` \while -> is_loop_condition
                                    `bind` \condition -> singleChar ')' 
                                    `bind` \close -> tokenize " do " 
                                    `bind` \opendo -> (my_parser) 
                                    `bind` \body -> tokenize " od" 
                                    `bind` \closedo ->
                        result (WhileLoop condition body)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent Once again, the bind operator keeps the communication between the present parsers clean and easy to follow. The \textit{tokenizer} is being used to recognize keywords together with spaces or opening brackets: \textbf{``while("}, \textbf{`` do "}, and \textbf{`` od"}. Furthermore, the mission of \textbf{my\textunderscore parser} is to parse any \textit{AST} data which is contained within the while loop considering other while loops as well. This will allow the parsing of nested while loops as well.  
    
    \subsection{Combining Statements}
    
    In this section, all the parsers that recognized the statements of our language will be combined into one parser called \textbf{parse\textunderscore all}. In order to achieve this, multiple \textit{alternation} operators (+++) were used between the different parsers of the statements.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    parse_all :: Parse AST
    parse_all  = parse_print +++ parse_get +++ parse_declaration_int 
                 +++ parse_declaration_string +++ parse_assignment_op 
                 +++ parse_assignment_var +++ parse_while_loop
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The order in which the parsers are arranged between the \textit{alternating} operators will not matter. Why? This is due to the fact that from the first character parsed on each statement nothing in common will be found between these parsers. Therefore, the parsers will not get in the way of one another and the \textbf{parse\textunderscore all} parser will have guarantees that the \textbf{parse\textunderscore while\textunderscore loop} will always be reached. For example:
    
    \begin{center}
            \textbf{ghci$>$} parse\textunderscore all \textcolor{red}{``while(a $>$ b) do Integer c = 2 od"} \\
             $\big[$(\textcolor{green}{While (Condition ``a" GreaterThan ``b") $\big[$ DeclarationInt ``a" 2 $\big]$}, \textcolor{red}{``"})$\big]$
        \end{center}
    
    
    \subsection{Parsing a program}
    
    The current status of the program will able to recognize all the possible statement of our language. Nevertheless, it will be unable to parse multiple statements at the same time. Let's have a look at an example: 
    
    \begin{center}
            \textbf{ghci$>$} parse\textunderscore all \textcolor{red}{``Integer a = 2 String b = 'abc'"} \\
             $\big[$(\textcolor{green}{DeclarationInt ``a" 2}, \textcolor{red}{`` String b = 'abc'"})$\big]$
        \end{center}
        
    \noindent In order to simulate the behavior of a program, more than one statement at a time must be parsed. Before being able to do that, a way to divide statements should be established. Taking into consideration the approach taken in many imperative languages like C++ and Java, the \textbf{semicolon(;)} seems like a plausible way to achieve separation between statements. \\ \\ 
    Obviously, a new parser needs to be constructed to produce this new behavior. The type of this parser will be \textbf{Parse [AST]} instead of \textbf{Parse AST} since we are trying to parse a list of statements instead of just a single statement. It is already known how to parse a single statement. This parser can be binded with a \textbf{tokenizer} that  recognizes a semicolon. This will produce already half of the desired behavior. What is left is to parse the rest of the list of AST. To do this, a parser that takes an AST parser and return a list of AST parsers was created.
     
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    iterate :: Parse AST -> Parse [AST] 
    iterate parser  = (parser `bind` \statement -> tokenize ";" 
                               `bind` \semicolon -> iterate parser 
                               `bind` \statements -> 
                        result (statement : statements)) 
                        +++ result []
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textbf{iterate} parser will be applied recursively to the final parser by producing the effect of parsing multiple statements which are divided by a tokenizer (which recognizes a semicolon). This brings us to the construction of the final parser that produces the desired behavior of parsing all the statements of the programming language in one go. The \textbf{my\textunderscore parser} is presented below:
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    my_parser :: Parse [AST]
    my_parser  = parse_all `bind` \statement -> tokenize ";" 
                           `bind` \semicolon -> iterate parse_all 
                           `bind` \statements -> 
                result (statement : statements)
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent Initially, the \textbf{parse\textunderscore all} parser is utilized to parse the first statement of the input string. The remaining input to be parsed is binded through the \textit{tokenizer} with a semicolon. After parsing (statement;), the string yet to be parsed is binded with the iterate parser which will take as input the \textbf{parse\textunderscore all} parser and will iterate over itself to produce a list of parsed AST. Finally, the \textbf{result} parser will return the list of AST statements parsed from the input string. \\ \\
    The parsing of our programming language can be illustrated with the following example which will parse 3 statements and return their corresponding AST.
    
    \begin{center}
            \textbf{ghci$>$} parse\textunderscore all \textcolor{red}{``Integer a = 2;String b = 'rera';a := b;"} \\
             $\big[$($\big[$\textcolor{green}{DeclarationInt ``a" 2}, \textcolor{green}{DeclarationString ``b" 'rera'}, \textcolor{green}{AssignmentVar ``a" ``b"}$\big]$, \textcolor{red}{``"})]
        \end{center}
        
    \section{Evaluator}
    
    In this section, the outcome of \textbf{my\textunderscore parser} will be evaluated with the utilization of the \textit{state} monad and errors will be handled with the \textit{exception} monad. These monads have not been imported from the Haskell language but have been re-created together with their accompanying monadic behavior. In addition, the approach taken to evaluate each statement of the simple programming language is observed and the helper monadic functions that were constructed are discussed in detail. Let's dive in. 
    
    \subsection{State}
    
    The state in functional programming is mirrored by the creation of a type that illustrate computations that are performed on a state. 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    type StateMonad a = Store -> (a, Store) 
    \end{lstlisting}
    \end{tcolorbox}
    \noindent The idea behind the state monad of type \textit{a} is that it takes as input the \textit{old state} and returns a tuple containing the value of a type \textit{a} and the \textit{new state}. A small adjustment was made in this program by replacing the state with a store which in turn is a list of \textit{Variable}. \textit{Variable} is a algebraic data type and will contain a composition of only two value constructors \textbf{IntVar} and \textbf{StringVar} since in our programming language only two types of values are allowed (\textit{Integers} and \textit{Strings}). 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    type Store = [Variable]
    data Variable = IntVar String Int 
                  | StringVar String String 
                      deriving (Show, Eq) 
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The type constructor StateMonad is not a monad yet. Recalling from section 3, a monad is achieved by additionally defining the \textit{bind} operator and the \textit{return} function for the StateMonad and making sure that the monadic laws hold. Let's observe how the \textbf{bindS} and \textbf{returnS} are constructed and implemented: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    returnS         :: a -> StateMonad a 
    returnS a store = (a, store)
    \end{lstlisting}
    \end{tcolorbox}
    \noindent The \textbf{returnS} function will take as input a value of type \textit{a} and a \textit{store} and will simlpy return a tuple containing the value of type \textit{a} and the unmodified \textit{store}.
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    bindS      :: StateMonad a -> (a -> StateMonad b) -> StateMonad b
    m `bindS` f = \store -> let (x, store') = m store in
                              let m' = f x in
                                 m' store'  
    \end{lstlisting}
    \end{tcolorbox}
    \noindent The \textbf{bindS} operator will perform computation \textit{m} in the initial \textit{store} and yield a tuple containing a value \textit{x} and the intermediate \textit{store'}. Afterwards, it perform computation \textit{f x} or \textit{m'} on the intermediate \textit{store'} thus by yielding the resulting value and the final version of the \textit{store}. 
    
    
    \subsection{Exceptions}
    
    Every program will throw errors from now and then. That's why error handling is an important feature and has to be included in our simple programming language. The \textit{Exception} monad provides an efficient way of handling errors for a computation by either raising an exception or returning the corresponding value.  
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    data Exceptions a = Raise Exception | Return a deriving (Show, Eq)
    type Exception = String 
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent In order to retrieve a monad out of the Exceptions type constructor, the \textbf{bindE} operator and the \textbf{returnE} function have been defined below: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    returnE  :: a -> Exceptions a 
    returnE a = Return a
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The function \textbf{returnE} takes as an input a value of type \textit{a} and simply returns that value without raising an exception.
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    bindE      :: Exceptions a -> (a -> Exceptions b) -> Exceptions b
    m `bindE` f = case m of 
                    Raise e -> Raise e 
                    Return a -> f a
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textbf{bindE} operator will initially examine the outcome of the computation \textit{m} through the \textbf{case of} construct. If \textit{m} raises an exception then the corresponding exception will be re-raised. Otherwise, if \textit{m} returns a value then function \textit{f} will be applied to that value. 
    
    
    \subsection{The Store}
    In order to be able to evaluate any of the statements, the store needs to be considered as a point of reference. Lets recall the form of the simple variable assignment statement \textit{a := b}. If this statement is to be evaluated then the store has to be first checked to see if variables \textit{a} and \textit{b} exist. Afterwards, it has to assign the value of the variable \textit{b} into the variable \textit{a} and then put the variable \textit{b} in the store with the updated value. In other words, the three most important monadic functions to be constructed are \textbf{getting} a variable from the store, \textbf{putting} variable in the store, and \textbf{removing} a variable from the store. How can this be achieved? The StateMonad can be exploited to allow the store to accessed and modified. Let's see how this is done in the two following subsections.
    
    \subsubsection{Putting a Variable in the Store}
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    putInStore    :: Variable -> StateMonad (Exceptions Variable) 
    putInStore var = \store -> 
     case (filter (\v -> (getVarName v) == (getVarName var)) store) of
      []     -> returnS (returnE var) (var : store)                               
      (x:xs) -> returnS (raise ("variable " ++ (getVarName var)
                                          ++ " already exists")) store
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textbf{putInStore} function is taking a \textit{Variable} and a \textit{Store} to then return a tuple containing an Exception data type and the \textit{Store} (modified or not). The Exception data either raises an \textit{Exception} or returns a \textit{Variable}. The \textbf{case of} construct is used taking the result of a filter being applied to the \textit{Store}. The filter will check if the \textit{Store} contains the \textit{Variable} provided as an input in the \textbf{putInStore} function. This look up is done on the name of the \textit{Variable} which is achieved by applying the function \textbf{getVarName} to the \textit{Variable}. If the check would be performed directly on the \textit{Variable} type then the filter will produce unwanted behavior and allow \textit{Variable} in the following example to be placed in the \textit{Store}. 
    \begin{center}
            \textbf{ghci$>$} putInStore \textcolor{red}{(IntVar ``a" 5)} \textcolor{green}{ $\big[$ IntVar "a" 6 $\big]$} \\
             (Return (IntVar ``a" 5),\textcolor{green}{$\big[$IntVar ``a" 5, IntVar ``a" 6$\big]$})
        \end{center}
    
    \noindent This is not the behavior that it is desired since the store now contains two identical variable names with different values. Consequently, the implementation of the \textbf{getVarName} follows below: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    getVarName                 :: Variable -> String
    getVarName (IntVar name _) = name
    getVarName (StringVar name _) = name
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent Applying the filter to the \textit{store} list will result in two outcomes. If the list is empty means that the variable does not exist and it can be safely put in the store. Thus, a tuple is returned containing the new \textit{Variable} and the modified store with the new \textit{Variable} included. Otherwise, if the list is non empty then a tuple is returned containing a raised exception saying that the variable name already exists and the unmodified store as a result.
    
    \subsubsection{Getting a Variable from the Store}
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    getFromStore      :: String -> StateMonad (Exceptions Variable)
    getFromStore name = \store -> 
    case (filter (\v -> getVarName v == name ) store) of 
    []  -> returnS (raise ("variable " ++ name 
                                       ++ " does not exist")) store 
    (x:xs) -> returnS (returnE x) store 
    
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textbf{getFromStore} function is taking the name of the variable as a \textit{String} and a \textit{Store} to then return a tuple containing an Exception data type and the unmodified \textit{Store}. As in the \textbf{putInStore} function, the \textit{Exception} data either raises an exception or returns a \textit{Variable}. The approach taken here is similar to the one taken when constructing the \textbf{putInStore} function, besides some modification to the outcomes of the \textbf{case of} construct. If an empty list is returned then a tuple is returned containing a raised exception saying that the variable requested does no exist and the unchanged store. Otherwise, if a list is non empty then a tuple is returned containing the corresponding \textit{Variable} returned and the unmodified store. 
    
    \subsubsection{Removing a Variable from the Store}
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    removeFromStore    :: Variable -> StateMonad () 
    removeFromStore var = \store -> returnS () (delete var store) 
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textbf{removeFromStore} function will take a \textit{Variable} and a \textit{Store} to then return a tuple containing \textit{nothing} and the \textit{Store} without the previously specified \textit{Variable}. The implementation of this monadic function is very straightforward. The only functionality needed is the \textbf{delete} from \textit{Data.List} which will directly remove the \textit{Variable} from the \textit{Store}.  
    
    \subsection{Evaluating Parsed Statements}
    
    Having constructed the most important operations \textit{to} and \textit{from} the Store will give the green light to the evaluation of the statements of our simple programming language. Let's see how the evaluate function is constructed: 
    
    \begin{tcolorbox}
    \begin{lstlisting}[language=Haskell] 
    evaluate :: State -> StateMonad (Exceptions Variable)
    evaluate input = case my_parser input of
                       []    -> returnS (raise "no parse") 
                       [(list,_)] -> transform list
    \end{lstlisting}
    \end{tcolorbox}
    
    \noindent The \textbf{evaluate} function will received an \textit{input string} and a \textit{Store} to then produce a tuple containing a \textit{Raised Exception} or the corresponding \textit{Variable} and the \textit{Store} (modified or not). Initially, the \textbf{case of} construct is utilized to observe the possible outcome from applying the \textbf{my\textunderscore parser} defined in section 5.5 to the specified \textit{input string}. Recalling from the implementation of \textbf{Parser} monad, the outcome is a list containing a tuple of parsed input and remaining unparsed input. Consequently, if an empty list is returned then a tuple will be returned containing the raised exception that nothing was parsed and the unchanged \textit{Store}. In case the list is non empty, it will mean that something was parsed. Therefore, the parsed statement being a list (according to the \textbf{Parse [AST]}) is taken out and placed as an input value to the function \textbf{transform}. Why use \textbf{transform}? In order to evaluate a program, the statements need to be parsed separately. That's where the \textbf{transform} function comes in play by taking each parsed statement of the list to then evaluate it and use the recursive property that comes along with lists to continue the evaluation for the remaining parsed statements of the list.
    
    \begin{thebibliography}{9}
    \bibitem{categorytheory} 
    M. D. Hill, Jonathan & Clarke, Keith. (1994). \textit{An Introduction to Category Theory, Category Theory Monads, and Their Relationship to Functional Programming}.
    \bibitem{essenceFP}
    Wadler, P. (1992b). \textit{The essence of functional programming. In
    20th ACM Symposium on Principles of Programming Languages}
    (POPL’92), pages 1–14. ACM, Albuquerque.
    \bibitem{original}
    Walder, P. \textit{Monads for functional programming}, section 5.2. University of Glasgow. 
    \bibitem{pearls}
    Hutton, G. and Meijer, E. \textit{Monadic Parsing in Haskell}. University of Nottingham.
    \bibitem{bringMonadComprehension}
    Giorgidze. G, Grust. T, Schweinsberg. N, and Weijers. J. \textit{Bring Back Monad Comprehensions}. Wilhelm-Schickard-Institut fur Informatik and Eberhard Karls Universitat Tubingen.
    \end{thebibliography}
    \end{document}
    