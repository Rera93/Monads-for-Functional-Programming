\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
 \geometry{
 a4paper,
 }
\title{Monads for Functional Programming}
\author{Brigel Pineti}
\begin{document}

\maketitle

\noindent\textbf{Abstract.} The paper from Philip Wadler describes the usage of monads to structure functional programs and to integrate impure effect into pure functional languages. The concept of a monad which arises from category theory provides a convenient framework for simulating effects found in other programming languages such as global state, exception handling, output and non-determinism. Two case studies are looked in detail: how monads act as a datatype of arrays to mimic in-place update and how monads can be used to build recursive decent parsers. \\ \\
\textbf{State.} The current state of a program execution is modelled by an array where indices are identifiers and the corresponding values are integers. It is easy to add arrays to a functional language and easy to provide efficient array lookup. On the other hand, providing an efficient array update is a question with a long history that has been answered through the usage of monads by defining new language features. The adequate way to implement the update operation is by evaluating the new value before placing it in the array without violating the single threaded property of the array. An alternative way for an array to satisfy the single threaded property is by explicitly indicating it through monad transformers taking an initial array and returning a value and a final array. Turning a monad m into an abstract data type supporting five operations: \textit{return}, \textit{${>>}$=}, \textit{block}, \textit{fetch} and \textit{assign} guarantees that single threading is preserved and hence it is safe to implement assignment with an in-place update. The use of data abstraction is essential for this purpose. Otherwise one could write programs that violate this property. One drawback of this is that is introduces too much sequencing. To remedy the spurious sequencing, the monad of state transformers M is augmented with a second monad of state readers. The state reader monad is commutative, while the state transformer monad is not. So no spurious order is imposed on the computations of the state reader monad. \\ \\
\textbf{Parsers.} Parsers are represented in a way similar to state transformers and depend upon lists. The list comprehension notation provides a convenient way of manipulating lists and translates neatly into monadic operations. A parser for type \textit{a}  takes a state representing a string to be parsed, and returns a list containing the value of type \textit{a} parsed from the string, and a state representing the remaining string yet to be parsed. In order to transform parsers into a monad, operations like \textit{return} and \textit{${>>}$=} need to be defined. The \textit{return} operation corresponds to the empty parser, which consumes no input and \textit{${>>}$=} operation complements to sequencing of parsers. Additionally, parsers may be combined by alternation by defining \textit{zero} and ${\oplus}$ operations. The parser \textit{zero} takes some input \textit{x} and always fails whereas the parser \textit{m} ${\oplus}$ \textit{n} takes input \textit{x} and yields all parses of \textit{m} applied to input \textit{x} and all parses of \textit{n} applied to the same input \textit{x}. Sequencing and alternation are fundamental not just to parsers but to computing in general. According to this paper, monads that capture both sequencing and alternation are achieved by combining together all the above mentioned operations.
\end{document}
